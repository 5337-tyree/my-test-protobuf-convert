// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/gyroflow.proto

#include "gyroflow.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace gyroflow {

inline constexpr Quaternion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : w_{0},
        x_{0},
        y_{0},
        z_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Quaternion::Quaternion(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;

inline constexpr MeshWarpData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : values_{},
        grid_width_{0},
        grid_height_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MeshWarpData::MeshWarpData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MeshWarpDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeshWarpDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeshWarpDataDefaultTypeInternal() {}
  union {
    MeshWarpData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeshWarpDataDefaultTypeInternal _MeshWarpData_default_instance_;

inline constexpr LensOISData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : sample_timestamp_us_{0},
        x_{0},
        y_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LensOISData::LensOISData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LensOISDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LensOISDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LensOISDataDefaultTypeInternal() {}
  union {
    LensOISData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LensOISDataDefaultTypeInternal _LensOISData_default_instance_;

inline constexpr LensData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        distortion_coefficients_{},
        camera_intrinsic_matrix_{},
        distortion_model_{static_cast< ::gyroflow::LensData_DistortionModel >(0)},
        focal_length_mm_{0},
        f_number_{0},
        focus_distance_mm_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LensData::LensData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LensDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LensDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LensDataDefaultTypeInternal() {}
  union {
    LensData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LensDataDefaultTypeInternal _LensData_default_instance_;

inline constexpr IMUData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        sample_timestamp_us_{0},
        gyroscope_x_{0},
        gyroscope_y_{0},
        gyroscope_z_{0},
        accelerometer_x_{0},
        accelerometer_y_{0},
        accelerometer_z_{0},
        magnetometer_x_{0},
        magnetometer_y_{0},
        magnetometer_z_{0} {}

template <typename>
PROTOBUF_CONSTEXPR IMUData::IMUData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IMUDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUDataDefaultTypeInternal() {}
  union {
    IMUData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUDataDefaultTypeInternal _IMUData_default_instance_;

inline constexpr IBISData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : sample_timestamp_us_{0},
        shift_x_{0},
        shift_y_{0},
        roll_angle_degrees_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR IBISData::IBISData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IBISDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IBISDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IBISDataDefaultTypeInternal() {}
  union {
    IBISData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IBISDataDefaultTypeInternal _IBISData_default_instance_;

inline constexpr Header_ClipMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        color_profile_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        frame_width_{0u},
        frame_height_{0u},
        duration_us_{0},
        record_frame_rate_{0},
        sensor_frame_rate_{0},
        file_frame_rate_{0},
        rotation_degrees_{0},
        imu_sample_rate_{0u},
        pixel_aspect_ratio_{0},
        frame_readout_time_us_{0},
        frame_readout_direction_{static_cast< ::gyroflow::Header_ClipMetadata_ReadoutDirection >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Header_ClipMetadata::Header_ClipMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Header_ClipMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Header_ClipMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Header_ClipMetadataDefaultTypeInternal() {}
  union {
    Header_ClipMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Header_ClipMetadataDefaultTypeInternal _Header_ClipMetadata_default_instance_;

inline constexpr QuaternionData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        quat_{nullptr},
        sample_timestamp_us_{0} {}

template <typename>
PROTOBUF_CONSTEXPR QuaternionData::QuaternionData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuaternionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDataDefaultTypeInternal() {}
  union {
    QuaternionData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDataDefaultTypeInternal _QuaternionData_default_instance_;

inline constexpr Header_CameraMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        camera_brand_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        camera_model_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        camera_serial_number_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        firmware_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        lens_brand_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        lens_model_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        lens_profile_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        imu_orientation_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        additional_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        imu_rotation_{nullptr},
        quats_rotation_{nullptr},
        pixel_pitch_nm_{0u},
        sensor_pixel_width_{0u},
        sensor_pixel_height_{0u},
        crop_factor_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Header_CameraMetadata::Header_CameraMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Header_CameraMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Header_CameraMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Header_CameraMetadataDefaultTypeInternal() {}
  union {
    Header_CameraMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Header_CameraMetadataDefaultTypeInternal _Header_CameraMetadata_default_instance_;

inline constexpr EISData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        matrix_4x4_{},
        quaternion_{nullptr},
        mesh_warp_{nullptr},
        sample_timestamp_us_{0},
        type_{static_cast< ::gyroflow::EISData_EISDataType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR EISData::EISData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EISDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EISDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EISDataDefaultTypeInternal() {}
  union {
    EISData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EISDataDefaultTypeInternal _EISData_default_instance_;

inline constexpr Header::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        camera_{nullptr},
        clip_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Header::Header(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct HeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderDefaultTypeInternal _Header_default_instance_;

inline constexpr FrameMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        lens_{},
        imu_{},
        quaternions_{},
        ois_{},
        ibis_{},
        eis_{},
        start_timestamp_us_{0},
        end_timestamp_us_{0},
        frame_number_{0u},
        iso_{0u},
        exposure_time_us_{0},
        white_balance_kelvin_{0u},
        white_balance_tint_{0},
        digital_zoom_ratio_{0},
        shutter_speed_numerator_{0},
        shutter_speed_denumerator_{0},
        shutter_angle_degrees_{0},
        crop_x_{0},
        crop_y_{0},
        crop_width_{0},
        crop_height_{0} {}

template <typename>
PROTOBUF_CONSTEXPR FrameMetadata::FrameMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct FrameMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameMetadataDefaultTypeInternal() {}
  union {
    FrameMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameMetadataDefaultTypeInternal _FrameMetadata_default_instance_;

inline constexpr Main::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        magic_string_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        header_{nullptr},
        frame_{nullptr},
        protocol_version_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Main::Main(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MainDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MainDefaultTypeInternal() {}
  union {
    Main _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MainDefaultTypeInternal _Main_default_instance_;
}  // namespace gyroflow
static ::_pb::Metadata file_level_metadata_proto_2fgyroflow_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_proto_2fgyroflow_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_proto_2fgyroflow_2eproto = nullptr;
const ::uint32_t TableStruct_proto_2fgyroflow_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _impl_.magic_string_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _impl_.protocol_version_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Main, _impl_.frame_),
    ~0u,
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.camera_brand_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.camera_model_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.camera_serial_number_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.firmware_version_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.lens_brand_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.lens_model_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.pixel_pitch_nm_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.sensor_pixel_width_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.sensor_pixel_height_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.crop_factor_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.lens_profile_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.imu_orientation_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.imu_rotation_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.quats_rotation_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_CameraMetadata, _impl_.additional_data_),
    ~0u,
    ~0u,
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    7,
    2,
    3,
    5,
    6,
    4,
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.frame_width_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.frame_height_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.duration_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.record_frame_rate_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.sensor_frame_rate_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.file_frame_rate_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.rotation_degrees_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.imu_sample_rate_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.color_profile_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.pixel_aspect_ratio_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.frame_readout_time_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header_ClipMetadata, _impl_.frame_readout_direction_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header, _impl_.camera_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Header, _impl_.clip_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.start_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.end_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.frame_number_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.iso_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.exposure_time_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.white_balance_kelvin_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.white_balance_tint_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.digital_zoom_ratio_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.shutter_speed_numerator_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.shutter_speed_denumerator_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.shutter_angle_degrees_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.crop_x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.crop_y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.crop_width_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.crop_height_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.lens_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.imu_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.quaternions_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.ois_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.ibis_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::FrameMetadata, _impl_.eis_),
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.distortion_model_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.distortion_coefficients_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.camera_intrinsic_matrix_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.focal_length_mm_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.f_number_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensData, _impl_.focus_distance_mm_),
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.sample_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.gyroscope_x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.gyroscope_y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.gyroscope_z_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.accelerometer_x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.accelerometer_y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.accelerometer_z_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.magnetometer_x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.magnetometer_y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IMUData, _impl_.magnetometer_z_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::gyroflow::Quaternion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::Quaternion, _impl_.w_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Quaternion, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Quaternion, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::Quaternion, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::QuaternionData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::QuaternionData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::QuaternionData, _impl_.sample_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::QuaternionData, _impl_.quat_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensOISData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensOISData, _impl_.sample_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensOISData, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::LensOISData, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::gyroflow::IBISData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::IBISData, _impl_.sample_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IBISData, _impl_.shift_x_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IBISData, _impl_.shift_y_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::IBISData, _impl_.roll_angle_degrees_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_.sample_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_.quaternion_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_.mesh_warp_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::EISData, _impl_.matrix_4x4_),
    2,
    ~0u,
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::gyroflow::MeshWarpData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::gyroflow::MeshWarpData, _impl_.grid_width_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::MeshWarpData, _impl_.grid_height_),
    PROTOBUF_FIELD_OFFSET(::gyroflow::MeshWarpData, _impl_.values_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 12, -1, sizeof(::gyroflow::Main)},
        {16, 39, -1, sizeof(::gyroflow::Header_CameraMetadata)},
        {54, 74, -1, sizeof(::gyroflow::Header_ClipMetadata)},
        {86, 96, -1, sizeof(::gyroflow::Header)},
        {98, 127, -1, sizeof(::gyroflow::FrameMetadata)},
        {148, 162, -1, sizeof(::gyroflow::LensData)},
        {168, 186, -1, sizeof(::gyroflow::IMUData)},
        {196, -1, -1, sizeof(::gyroflow::Quaternion)},
        {208, 218, -1, sizeof(::gyroflow::QuaternionData)},
        {220, -1, -1, sizeof(::gyroflow::LensOISData)},
        {231, -1, -1, sizeof(::gyroflow::IBISData)},
        {243, 256, -1, sizeof(::gyroflow::EISData)},
        {261, -1, -1, sizeof(::gyroflow::MeshWarpData)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::gyroflow::_Main_default_instance_._instance,
    &::gyroflow::_Header_CameraMetadata_default_instance_._instance,
    &::gyroflow::_Header_ClipMetadata_default_instance_._instance,
    &::gyroflow::_Header_default_instance_._instance,
    &::gyroflow::_FrameMetadata_default_instance_._instance,
    &::gyroflow::_LensData_default_instance_._instance,
    &::gyroflow::_IMUData_default_instance_._instance,
    &::gyroflow::_Quaternion_default_instance_._instance,
    &::gyroflow::_QuaternionData_default_instance_._instance,
    &::gyroflow::_LensOISData_default_instance_._instance,
    &::gyroflow::_IBISData_default_instance_._instance,
    &::gyroflow::_EISData_default_instance_._instance,
    &::gyroflow::_MeshWarpData_default_instance_._instance,
};
const char descriptor_table_protodef_proto_2fgyroflow_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\024proto/gyroflow.proto\022\010gyroflow\"\200\001\n\004Mai"
    "n\022\024\n\014magic_string\030\001 \001(\t\022\030\n\020protocol_vers"
    "ion\030\002 \001(\r\022 \n\006header\030\003 \001(\0132\020.gyroflow.Hea"
    "der\022&\n\005frame\030\004 \001(\0132\027.gyroflow.FrameMetad"
    "ata\"\265\t\n\006Header\022/\n\006camera\030\001 \001(\0132\037.gyroflo"
    "w.Header.CameraMetadata\022+\n\004clip\030\002 \001(\0132\035."
    "gyroflow.Header.ClipMetadata\032\347\004\n\016CameraM"
    "etadata\022\024\n\014camera_brand\030\001 \001(\t\022\024\n\014camera_"
    "model\030\002 \001(\t\022!\n\024camera_serial_number\030\003 \001("
    "\tH\000\210\001\001\022\035\n\020firmware_version\030\004 \001(\tH\001\210\001\001\022\022\n"
    "\nlens_brand\030\005 \001(\t\022\022\n\nlens_model\030\006 \001(\t\022\026\n"
    "\016pixel_pitch_nm\030\007 \001(\r\022\032\n\022sensor_pixel_wi"
    "dth\030\010 \001(\r\022\033\n\023sensor_pixel_height\030\t \001(\r\022\030"
    "\n\013crop_factor\030\n \001(\002H\002\210\001\001\022\031\n\014lens_profile"
    "\030\013 \001(\tH\003\210\001\001\022\034\n\017imu_orientation\030\014 \001(\tH\004\210\001"
    "\001\022/\n\014imu_rotation\030\r \001(\0132\024.gyroflow.Quate"
    "rnionH\005\210\001\001\0221\n\016quats_rotation\030\016 \001(\0132\024.gyr"
    "oflow.QuaternionH\006\210\001\001\022\034\n\017additional_data"
    "\030\017 \001(\tH\007\210\001\001B\027\n\025_camera_serial_numberB\023\n\021"
    "_firmware_versionB\016\n\014_crop_factorB\017\n\r_le"
    "ns_profileB\022\n\020_imu_orientationB\017\n\r_imu_r"
    "otationB\021\n\017_quats_rotationB\022\n\020_additiona"
    "l_data\032\342\003\n\014ClipMetadata\022\023\n\013frame_width\030\001"
    " \001(\r\022\024\n\014frame_height\030\002 \001(\r\022\023\n\013duration_u"
    "s\030\003 \001(\002\022\031\n\021record_frame_rate\030\004 \001(\002\022\031\n\021se"
    "nsor_frame_rate\030\005 \001(\002\022\027\n\017file_frame_rate"
    "\030\006 \001(\002\022\030\n\020rotation_degrees\030\007 \001(\005\022\027\n\017imu_"
    "sample_rate\030\010 \001(\r\022\032\n\rcolor_profile\030\t \001(\t"
    "H\000\210\001\001\022\032\n\022pixel_aspect_ratio\030\n \001(\002\022\035\n\025fra"
    "me_readout_time_us\030\013 \001(\002\022O\n\027frame_readou"
    "t_direction\030\014 \001(\0162..gyroflow.Header.Clip"
    "Metadata.ReadoutDirection\"V\n\020ReadoutDire"
    "ction\022\017\n\013TopToBottom\020\000\022\017\n\013BottomToTop\020\001\022"
    "\017\n\013RightToLeft\020\002\022\017\n\013LeftToRight\020\003B\020\n\016_co"
    "lor_profile\"\204\007\n\rFrameMetadata\022\032\n\022start_t"
    "imestamp_us\030\001 \001(\001\022\030\n\020end_timestamp_us\030\002 "
    "\001(\001\022\024\n\014frame_number\030\003 \001(\r\022\020\n\003iso\030\004 \001(\rH\000"
    "\210\001\001\022\035\n\020exposure_time_us\030\005 \001(\002H\001\210\001\001\022!\n\024wh"
    "ite_balance_kelvin\030\006 \001(\rH\002\210\001\001\022\037\n\022white_b"
    "alance_tint\030\007 \001(\002H\003\210\001\001\022\037\n\022digital_zoom_r"
    "atio\030\010 \001(\002H\004\210\001\001\022$\n\027shutter_speed_numerat"
    "or\030\t \001(\005H\005\210\001\001\022&\n\031shutter_speed_denumerat"
    "or\030\n \001(\005H\006\210\001\001\022\"\n\025shutter_angle_degrees\030\013"
    " \001(\002H\007\210\001\001\022\023\n\006crop_x\030\014 \001(\002H\010\210\001\001\022\023\n\006crop_y"
    "\030\r \001(\002H\t\210\001\001\022\027\n\ncrop_width\030\016 \001(\002H\n\210\001\001\022\030\n\013"
    "crop_height\030\017 \001(\002H\013\210\001\001\022 \n\004lens\030\020 \003(\0132\022.g"
    "yroflow.LensData\022\036\n\003imu\030\021 \003(\0132\021.gyroflow"
    ".IMUData\022-\n\013quaternions\030\022 \003(\0132\030.gyroflow"
    ".QuaternionData\022\"\n\003ois\030\023 \003(\0132\025.gyroflow."
    "LensOISData\022 \n\004ibis\030\024 \003(\0132\022.gyroflow.IBI"
    "SData\022\036\n\003eis\030\025 \003(\0132\021.gyroflow.EISDataB\006\n"
    "\004_isoB\023\n\021_exposure_time_usB\027\n\025_white_bal"
    "ance_kelvinB\025\n\023_white_balance_tintB\025\n\023_d"
    "igital_zoom_ratioB\032\n\030_shutter_speed_nume"
    "ratorB\034\n\032_shutter_speed_denumeratorB\030\n\026_"
    "shutter_angle_degreesB\t\n\007_crop_xB\t\n\007_cro"
    "p_yB\r\n\013_crop_widthB\016\n\014_crop_height\"\211\003\n\010L"
    "ensData\022<\n\020distortion_model\030\001 \001(\0162\".gyro"
    "flow.LensData.DistortionModel\022\037\n\027distort"
    "ion_coefficients\030\002 \003(\002\022\037\n\027camera_intrins"
    "ic_matrix\030\003 \003(\002\022\034\n\017focal_length_mm\030\004 \001(\002"
    "H\000\210\001\001\022\025\n\010f_number\030\005 \001(\002H\001\210\001\001\022\036\n\021focus_di"
    "stance_mm\030\006 \001(\002H\002\210\001\001\"q\n\017DistortionModel\022"
    "\021\n\rOpenCVFisheye\020\000\022\022\n\016OpenCVStandard\020\001\022\t"
    "\n\005Poly3\020\002\022\t\n\005Poly5\020\003\022\n\n\006PTLens\020\004\022\025\n\021Gene"
    "ricPolynomial\020\005B\022\n\020_focal_length_mmB\013\n\t_"
    "f_numberB\024\n\022_focus_distance_mm\"\300\002\n\007IMUDa"
    "ta\022\033\n\023sample_timestamp_us\030\001 \001(\001\022\023\n\013gyros"
    "cope_x\030\002 \001(\002\022\023\n\013gyroscope_y\030\003 \001(\002\022\023\n\013gyr"
    "oscope_z\030\004 \001(\002\022\027\n\017accelerometer_x\030\005 \001(\002\022"
    "\027\n\017accelerometer_y\030\006 \001(\002\022\027\n\017acceleromete"
    "r_z\030\007 \001(\002\022\033\n\016magnetometer_x\030\010 \001(\002H\000\210\001\001\022\033"
    "\n\016magnetometer_y\030\t \001(\002H\001\210\001\001\022\033\n\016magnetome"
    "ter_z\030\n \001(\002H\002\210\001\001B\021\n\017_magnetometer_xB\021\n\017_"
    "magnetometer_yB\021\n\017_magnetometer_z\"8\n\nQua"
    "ternion\022\t\n\001w\030\001 \001(\002\022\t\n\001x\030\002 \001(\002\022\t\n\001y\030\003 \001(\002"
    "\022\t\n\001z\030\004 \001(\002\"Q\n\016QuaternionData\022\033\n\023sample_"
    "timestamp_us\030\001 \001(\001\022\"\n\004quat\030\002 \001(\0132\024.gyrof"
    "low.Quaternion\"@\n\013LensOISData\022\033\n\023sample_"
    "timestamp_us\030\001 \001(\001\022\t\n\001x\030\002 \001(\002\022\t\n\001y\030\003 \001(\002"
    "\"e\n\010IBISData\022\033\n\023sample_timestamp_us\030\001 \001("
    "\001\022\017\n\007shift_x\030\002 \001(\002\022\017\n\007shift_y\030\003 \001(\002\022\032\n\022r"
    "oll_angle_degrees\030\004 \001(\002\"\276\002\n\007EISData\022 \n\023s"
    "ample_timestamp_us\030\001 \001(\001H\000\210\001\001\022+\n\004type\030\002 "
    "\001(\0162\035.gyroflow.EISData.EISDataType\022-\n\nqu"
    "aternion\030\003 \001(\0132\024.gyroflow.QuaternionH\001\210\001"
    "\001\022.\n\tmesh_warp\030\004 \001(\0132\026.gyroflow.MeshWarp"
    "DataH\002\210\001\001\022\022\n\nmatrix_4x4\030\005 \003(\002\"<\n\013EISData"
    "Type\022\016\n\nQUATERNION\020\000\022\r\n\tMESH_WARP\020\001\022\016\n\nM"
    "ATRIX_4X4\020\002B\026\n\024_sample_timestamp_usB\r\n\013_"
    "quaternionB\014\n\n_mesh_warp\"G\n\014MeshWarpData"
    "\022\022\n\ngrid_width\030\001 \001(\005\022\023\n\013grid_height\030\002 \001("
    "\005\022\016\n\006values\030\003 \003(\002b\006proto3"
};
static ::absl::once_flag descriptor_table_proto_2fgyroflow_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_proto_2fgyroflow_2eproto = {
    false,
    false,
    3705,
    descriptor_table_protodef_proto_2fgyroflow_2eproto,
    "proto/gyroflow.proto",
    &descriptor_table_proto_2fgyroflow_2eproto_once,
    nullptr,
    0,
    13,
    schemas,
    file_default_instances,
    TableStruct_proto_2fgyroflow_2eproto::offsets,
    file_level_metadata_proto_2fgyroflow_2eproto,
    file_level_enum_descriptors_proto_2fgyroflow_2eproto,
    file_level_service_descriptors_proto_2fgyroflow_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_proto_2fgyroflow_2eproto_getter() {
  return &descriptor_table_proto_2fgyroflow_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_proto_2fgyroflow_2eproto(&descriptor_table_proto_2fgyroflow_2eproto);
namespace gyroflow {
const ::google::protobuf::EnumDescriptor* Header_ClipMetadata_ReadoutDirection_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_proto_2fgyroflow_2eproto);
  return file_level_enum_descriptors_proto_2fgyroflow_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Header_ClipMetadata_ReadoutDirection_internal_data_[] = {
    262144u, 0u, };
bool Header_ClipMetadata_ReadoutDirection_IsValid(int value) {
  return 0 <= value && value <= 3;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::TopToBottom;
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::BottomToTop;
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::RightToLeft;
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::LeftToRight;
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::ReadoutDirection_MIN;
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::ReadoutDirection_MAX;
constexpr int Header_ClipMetadata::ReadoutDirection_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LensData_DistortionModel_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_proto_2fgyroflow_2eproto);
  return file_level_enum_descriptors_proto_2fgyroflow_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t LensData_DistortionModel_internal_data_[] = {
    393216u, 0u, };
bool LensData_DistortionModel_IsValid(int value) {
  return 0 <= value && value <= 5;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LensData_DistortionModel LensData::OpenCVFisheye;
constexpr LensData_DistortionModel LensData::OpenCVStandard;
constexpr LensData_DistortionModel LensData::Poly3;
constexpr LensData_DistortionModel LensData::Poly5;
constexpr LensData_DistortionModel LensData::PTLens;
constexpr LensData_DistortionModel LensData::GenericPolynomial;
constexpr LensData_DistortionModel LensData::DistortionModel_MIN;
constexpr LensData_DistortionModel LensData::DistortionModel_MAX;
constexpr int LensData::DistortionModel_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* EISData_EISDataType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_proto_2fgyroflow_2eproto);
  return file_level_enum_descriptors_proto_2fgyroflow_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t EISData_EISDataType_internal_data_[] = {
    196608u, 0u, };
bool EISData_EISDataType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr EISData_EISDataType EISData::QUATERNION;
constexpr EISData_EISDataType EISData::MESH_WARP;
constexpr EISData_EISDataType EISData::MATRIX_4X4;
constexpr EISData_EISDataType EISData::EISDataType_MIN;
constexpr EISData_EISDataType EISData::EISDataType_MAX;
constexpr int EISData::EISDataType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class Main::_Internal {
 public:
  using HasBits = decltype(std::declval<Main>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Main, _impl_._has_bits_);
  static const ::gyroflow::Header& header(const Main* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gyroflow::FrameMetadata& frame(const Main* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gyroflow::Header& Main::_Internal::header(const Main* msg) {
  return *msg->_impl_.header_;
}
const ::gyroflow::FrameMetadata& Main::_Internal::frame(const Main* msg) {
  return *msg->_impl_.frame_;
}
Main::Main(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.Main)
}
inline PROTOBUF_NDEBUG_INLINE Main::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        magic_string_(arena, from.magic_string_) {}

Main::Main(
    ::google::protobuf::Arena* arena,
    const Main& from)
    : ::google::protobuf::Message(arena) {
  Main* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::gyroflow::Header>(arena, *from._impl_.header_)
                : nullptr;
  _impl_.frame_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::gyroflow::FrameMetadata>(arena, *from._impl_.frame_)
                : nullptr;
  _impl_.protocol_version_ = from._impl_.protocol_version_;

  // @@protoc_insertion_point(copy_constructor:gyroflow.Main)
}
inline PROTOBUF_NDEBUG_INLINE Main::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        magic_string_(arena) {}

inline void Main::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_),
           0,
           offsetof(Impl_, protocol_version_) -
               offsetof(Impl_, header_) +
               sizeof(Impl_::protocol_version_));
}
Main::~Main() {
  // @@protoc_insertion_point(destructor:gyroflow.Main)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Main::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.magic_string_.Destroy();
  delete _impl_.header_;
  delete _impl_.frame_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Main::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.Main)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.magic_string_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.frame_ != nullptr);
      _impl_.frame_->Clear();
    }
  }
  _impl_.protocol_version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Main::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 34, 2> Main::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Main, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Main_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .gyroflow.FrameMetadata frame = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(Main, _impl_.frame_)}},
    // string magic_string = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Main, _impl_.magic_string_)}},
    // uint32 protocol_version = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Main, _impl_.protocol_version_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Main, _impl_.protocol_version_)}},
    // .gyroflow.Header header = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(Main, _impl_.header_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string magic_string = 1;
    {PROTOBUF_FIELD_OFFSET(Main, _impl_.magic_string_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 protocol_version = 2;
    {PROTOBUF_FIELD_OFFSET(Main, _impl_.protocol_version_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .gyroflow.Header header = 3;
    {PROTOBUF_FIELD_OFFSET(Main, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .gyroflow.FrameMetadata frame = 4;
    {PROTOBUF_FIELD_OFFSET(Main, _impl_.frame_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::Header>()},
    {::_pbi::TcParser::GetTable<::gyroflow::FrameMetadata>()},
  }}, {{
    "\15\14\0\0\0\0\0\0"
    "gyroflow.Main"
    "magic_string"
  }},
};

::uint8_t* Main::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.Main)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string magic_string = 1;
  if (!this->_internal_magic_string().empty()) {
    const std::string& _s = this->_internal_magic_string();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Main.magic_string");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 protocol_version = 2;
  if (this->_internal_protocol_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_protocol_version(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .gyroflow.Header header = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .gyroflow.FrameMetadata frame = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.Main)
  return target;
}

::size_t Main::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.Main)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string magic_string = 1;
  if (!this->_internal_magic_string().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_magic_string());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .gyroflow.Header header = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_);
    }

    // .gyroflow.FrameMetadata frame = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.frame_);
    }

  }
  // uint32 protocol_version = 2;
  if (this->_internal_protocol_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_protocol_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Main::_class_data_ = {
    Main::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Main::GetClassData() const {
  return &_class_data_;
}

void Main::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Main*>(&to_msg);
  auto& from = static_cast<const Main&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.Main)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_magic_string().empty()) {
    _this->_internal_set_magic_string(from._internal_magic_string());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::gyroflow::Header::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_frame()->::gyroflow::FrameMetadata::MergeFrom(
          from._internal_frame());
    }
  }
  if (from._internal_protocol_version() != 0) {
    _this->_internal_set_protocol_version(from._internal_protocol_version());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Main::CopyFrom(const Main& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.Main)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Main::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Main::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Main::InternalSwap(Main* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.magic_string_, &other->_impl_.magic_string_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Main, _impl_.protocol_version_)
      + sizeof(Main::_impl_.protocol_version_)
      - PROTOBUF_FIELD_OFFSET(Main, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::google::protobuf::Metadata Main::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[0]);
}
// ===================================================================

class Header_CameraMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<Header_CameraMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_._has_bits_);
  static void set_has_camera_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crop_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_lens_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_imu_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::gyroflow::Quaternion& imu_rotation(const Header_CameraMetadata* msg);
  static void set_has_imu_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::gyroflow::Quaternion& quats_rotation(const Header_CameraMetadata* msg);
  static void set_has_quats_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_additional_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::gyroflow::Quaternion& Header_CameraMetadata::_Internal::imu_rotation(const Header_CameraMetadata* msg) {
  return *msg->_impl_.imu_rotation_;
}
const ::gyroflow::Quaternion& Header_CameraMetadata::_Internal::quats_rotation(const Header_CameraMetadata* msg) {
  return *msg->_impl_.quats_rotation_;
}
Header_CameraMetadata::Header_CameraMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.Header.CameraMetadata)
}
inline PROTOBUF_NDEBUG_INLINE Header_CameraMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        camera_brand_(arena, from.camera_brand_),
        camera_model_(arena, from.camera_model_),
        camera_serial_number_(arena, from.camera_serial_number_),
        firmware_version_(arena, from.firmware_version_),
        lens_brand_(arena, from.lens_brand_),
        lens_model_(arena, from.lens_model_),
        lens_profile_(arena, from.lens_profile_),
        imu_orientation_(arena, from.imu_orientation_),
        additional_data_(arena, from.additional_data_) {}

Header_CameraMetadata::Header_CameraMetadata(
    ::google::protobuf::Arena* arena,
    const Header_CameraMetadata& from)
    : ::google::protobuf::Message(arena) {
  Header_CameraMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.imu_rotation_ = (cached_has_bits & 0x00000020u)
                ? CreateMaybeMessage<::gyroflow::Quaternion>(arena, *from._impl_.imu_rotation_)
                : nullptr;
  _impl_.quats_rotation_ = (cached_has_bits & 0x00000040u)
                ? CreateMaybeMessage<::gyroflow::Quaternion>(arena, *from._impl_.quats_rotation_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pixel_pitch_nm_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, pixel_pitch_nm_),
           offsetof(Impl_, crop_factor_) -
               offsetof(Impl_, pixel_pitch_nm_) +
               sizeof(Impl_::crop_factor_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.Header.CameraMetadata)
}
inline PROTOBUF_NDEBUG_INLINE Header_CameraMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        camera_brand_(arena),
        camera_model_(arena),
        camera_serial_number_(arena),
        firmware_version_(arena),
        lens_brand_(arena),
        lens_model_(arena),
        lens_profile_(arena),
        imu_orientation_(arena),
        additional_data_(arena) {}

inline void Header_CameraMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, imu_rotation_),
           0,
           offsetof(Impl_, crop_factor_) -
               offsetof(Impl_, imu_rotation_) +
               sizeof(Impl_::crop_factor_));
}
Header_CameraMetadata::~Header_CameraMetadata() {
  // @@protoc_insertion_point(destructor:gyroflow.Header.CameraMetadata)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Header_CameraMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.camera_brand_.Destroy();
  _impl_.camera_model_.Destroy();
  _impl_.camera_serial_number_.Destroy();
  _impl_.firmware_version_.Destroy();
  _impl_.lens_brand_.Destroy();
  _impl_.lens_model_.Destroy();
  _impl_.lens_profile_.Destroy();
  _impl_.imu_orientation_.Destroy();
  _impl_.additional_data_.Destroy();
  delete _impl_.imu_rotation_;
  delete _impl_.quats_rotation_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Header_CameraMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.Header.CameraMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.camera_brand_.ClearToEmpty();
  _impl_.camera_model_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.camera_serial_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.firmware_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.lens_brand_.ClearToEmpty();
  _impl_.lens_model_.ClearToEmpty();
  if (cached_has_bits & 0x0000007cu) {
    if (cached_has_bits & 0x00000004u) {
      _impl_.lens_profile_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.imu_orientation_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.additional_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.imu_rotation_ != nullptr);
      _impl_.imu_rotation_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.quats_rotation_ != nullptr);
      _impl_.quats_rotation_->Clear();
    }
  }
  ::memset(&_impl_.pixel_pitch_nm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.sensor_pixel_height_) -
      reinterpret_cast<char*>(&_impl_.pixel_pitch_nm_)) + sizeof(_impl_.sensor_pixel_height_));
  _impl_.crop_factor_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Header_CameraMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 2, 169, 2> Header_CameraMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_._has_bits_),
    0, // no _extensions_
    15, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294934528,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Header_CameraMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string camera_brand = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_brand_)}},
    // string camera_model = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_model_)}},
    // optional string camera_serial_number = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_serial_number_)}},
    // optional string firmware_version = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.firmware_version_)}},
    // string lens_brand = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_brand_)}},
    // string lens_model = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_model_)}},
    // uint32 pixel_pitch_nm = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_CameraMetadata, _impl_.pixel_pitch_nm_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.pixel_pitch_nm_)}},
    // uint32 sensor_pixel_width = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_CameraMetadata, _impl_.sensor_pixel_width_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.sensor_pixel_width_)}},
    // uint32 sensor_pixel_height = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_CameraMetadata, _impl_.sensor_pixel_height_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.sensor_pixel_height_)}},
    // optional float crop_factor = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 7, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.crop_factor_)}},
    // optional string lens_profile = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 2, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_profile_)}},
    // optional string imu_orientation = 12;
    {::_pbi::TcParser::FastUS1,
     {98, 3, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.imu_orientation_)}},
    // optional .gyroflow.Quaternion imu_rotation = 13;
    {::_pbi::TcParser::FastMtS1,
     {106, 5, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.imu_rotation_)}},
    // optional .gyroflow.Quaternion quats_rotation = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 6, 1, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.quats_rotation_)}},
    // optional string additional_data = 15;
    {::_pbi::TcParser::FastUS1,
     {122, 4, 0, PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.additional_data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string camera_brand = 1;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_brand_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string camera_model = 2;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_model_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string camera_serial_number = 3;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.camera_serial_number_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string firmware_version = 4;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.firmware_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string lens_brand = 5;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_brand_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string lens_model = 6;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_model_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 pixel_pitch_nm = 7;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.pixel_pitch_nm_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 sensor_pixel_width = 8;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.sensor_pixel_width_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 sensor_pixel_height = 9;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.sensor_pixel_height_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // optional float crop_factor = 10;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.crop_factor_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional string lens_profile = 11;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.lens_profile_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string imu_orientation = 12;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.imu_orientation_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional .gyroflow.Quaternion imu_rotation = 13;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.imu_rotation_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .gyroflow.Quaternion quats_rotation = 14;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.quats_rotation_), _Internal::kHasBitsOffset + 6, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string additional_data = 15;
    {PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.additional_data_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::Quaternion>()},
    {::_pbi::TcParser::GetTable<::gyroflow::Quaternion>()},
  }}, {{
    "\36\14\14\24\20\12\12\0\0\0\0\14\17\0\0\17"
    "gyroflow.Header.CameraMetadata"
    "camera_brand"
    "camera_model"
    "camera_serial_number"
    "firmware_version"
    "lens_brand"
    "lens_model"
    "lens_profile"
    "imu_orientation"
    "additional_data"
  }},
};

::uint8_t* Header_CameraMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.Header.CameraMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string camera_brand = 1;
  if (!this->_internal_camera_brand().empty()) {
    const std::string& _s = this->_internal_camera_brand();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.camera_brand");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string camera_model = 2;
  if (!this->_internal_camera_model().empty()) {
    const std::string& _s = this->_internal_camera_model();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.camera_model");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string camera_serial_number = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_camera_serial_number();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.camera_serial_number");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string firmware_version = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_firmware_version();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.firmware_version");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string lens_brand = 5;
  if (!this->_internal_lens_brand().empty()) {
    const std::string& _s = this->_internal_lens_brand();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.lens_brand");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string lens_model = 6;
  if (!this->_internal_lens_model().empty()) {
    const std::string& _s = this->_internal_lens_model();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.lens_model");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // uint32 pixel_pitch_nm = 7;
  if (this->_internal_pixel_pitch_nm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_pixel_pitch_nm(), target);
  }

  // uint32 sensor_pixel_width = 8;
  if (this->_internal_sensor_pixel_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_sensor_pixel_width(), target);
  }

  // uint32 sensor_pixel_height = 9;
  if (this->_internal_sensor_pixel_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_sensor_pixel_height(), target);
  }

  // optional float crop_factor = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_crop_factor(), target);
  }

  // optional string lens_profile = 11;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_lens_profile();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.lens_profile");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string imu_orientation = 12;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_imu_orientation();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.imu_orientation");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // optional .gyroflow.Quaternion imu_rotation = 13;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        13, _Internal::imu_rotation(this),
        _Internal::imu_rotation(this).GetCachedSize(), target, stream);
  }

  // optional .gyroflow.Quaternion quats_rotation = 14;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        14, _Internal::quats_rotation(this),
        _Internal::quats_rotation(this).GetCachedSize(), target, stream);
  }

  // optional string additional_data = 15;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_additional_data();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.CameraMetadata.additional_data");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.Header.CameraMetadata)
  return target;
}

::size_t Header_CameraMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.Header.CameraMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string camera_brand = 1;
  if (!this->_internal_camera_brand().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_camera_brand());
  }

  // string camera_model = 2;
  if (!this->_internal_camera_model().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_camera_model());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string camera_serial_number = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_camera_serial_number());
    }

    // optional string firmware_version = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_firmware_version());
    }

  }
  // string lens_brand = 5;
  if (!this->_internal_lens_brand().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_lens_brand());
  }

  // string lens_model = 6;
  if (!this->_internal_lens_model().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_lens_model());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional string lens_profile = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_lens_profile());
    }

    // optional string imu_orientation = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_imu_orientation());
    }

    // optional string additional_data = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_additional_data());
    }

    // optional .gyroflow.Quaternion imu_rotation = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.imu_rotation_);
    }

    // optional .gyroflow.Quaternion quats_rotation = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.quats_rotation_);
    }

  }
  // uint32 pixel_pitch_nm = 7;
  if (this->_internal_pixel_pitch_nm() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_pixel_pitch_nm());
  }

  // uint32 sensor_pixel_width = 8;
  if (this->_internal_sensor_pixel_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_sensor_pixel_width());
  }

  // uint32 sensor_pixel_height = 9;
  if (this->_internal_sensor_pixel_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_sensor_pixel_height());
  }

  // optional float crop_factor = 10;
  if (cached_has_bits & 0x00000080u) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Header_CameraMetadata::_class_data_ = {
    Header_CameraMetadata::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Header_CameraMetadata::GetClassData() const {
  return &_class_data_;
}

void Header_CameraMetadata::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Header_CameraMetadata*>(&to_msg);
  auto& from = static_cast<const Header_CameraMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.Header.CameraMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_camera_brand().empty()) {
    _this->_internal_set_camera_brand(from._internal_camera_brand());
  }
  if (!from._internal_camera_model().empty()) {
    _this->_internal_set_camera_model(from._internal_camera_model());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_camera_serial_number(from._internal_camera_serial_number());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_firmware_version(from._internal_firmware_version());
    }
  }
  if (!from._internal_lens_brand().empty()) {
    _this->_internal_set_lens_brand(from._internal_lens_brand());
  }
  if (!from._internal_lens_model().empty()) {
    _this->_internal_set_lens_model(from._internal_lens_model());
  }
  if (cached_has_bits & 0x0000007cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_lens_profile(from._internal_lens_profile());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_imu_orientation(from._internal_imu_orientation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_additional_data(from._internal_additional_data());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_imu_rotation()->::gyroflow::Quaternion::MergeFrom(
          from._internal_imu_rotation());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_quats_rotation()->::gyroflow::Quaternion::MergeFrom(
          from._internal_quats_rotation());
    }
  }
  if (from._internal_pixel_pitch_nm() != 0) {
    _this->_internal_set_pixel_pitch_nm(from._internal_pixel_pitch_nm());
  }
  if (from._internal_sensor_pixel_width() != 0) {
    _this->_internal_set_sensor_pixel_width(from._internal_sensor_pixel_width());
  }
  if (from._internal_sensor_pixel_height() != 0) {
    _this->_internal_set_sensor_pixel_height(from._internal_sensor_pixel_height());
  }
  if (cached_has_bits & 0x00000080u) {
    _this->_internal_set_crop_factor(from._internal_crop_factor());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Header_CameraMetadata::CopyFrom(const Header_CameraMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.Header.CameraMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Header_CameraMetadata::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Header_CameraMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Header_CameraMetadata::InternalSwap(Header_CameraMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.camera_brand_, &other->_impl_.camera_brand_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.camera_model_, &other->_impl_.camera_model_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.camera_serial_number_, &other->_impl_.camera_serial_number_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.firmware_version_, &other->_impl_.firmware_version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lens_brand_, &other->_impl_.lens_brand_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lens_model_, &other->_impl_.lens_model_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lens_profile_, &other->_impl_.lens_profile_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.imu_orientation_, &other->_impl_.imu_orientation_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.additional_data_, &other->_impl_.additional_data_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.crop_factor_)
      + sizeof(Header_CameraMetadata::_impl_.crop_factor_)
      - PROTOBUF_FIELD_OFFSET(Header_CameraMetadata, _impl_.imu_rotation_)>(
          reinterpret_cast<char*>(&_impl_.imu_rotation_),
          reinterpret_cast<char*>(&other->_impl_.imu_rotation_));
}

::google::protobuf::Metadata Header_CameraMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[1]);
}
// ===================================================================

class Header_ClipMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<Header_ClipMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_._has_bits_);
  static void set_has_color_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Header_ClipMetadata::Header_ClipMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.Header.ClipMetadata)
}
inline PROTOBUF_NDEBUG_INLINE Header_ClipMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        color_profile_(arena, from.color_profile_) {}

Header_ClipMetadata::Header_ClipMetadata(
    ::google::protobuf::Arena* arena,
    const Header_ClipMetadata& from)
    : ::google::protobuf::Message(arena) {
  Header_ClipMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, frame_width_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, frame_width_),
           offsetof(Impl_, frame_readout_direction_) -
               offsetof(Impl_, frame_width_) +
               sizeof(Impl_::frame_readout_direction_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.Header.ClipMetadata)
}
inline PROTOBUF_NDEBUG_INLINE Header_ClipMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        color_profile_(arena) {}

inline void Header_ClipMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, frame_width_),
           0,
           offsetof(Impl_, frame_readout_direction_) -
               offsetof(Impl_, frame_width_) +
               sizeof(Impl_::frame_readout_direction_));
}
Header_ClipMetadata::~Header_ClipMetadata() {
  // @@protoc_insertion_point(destructor:gyroflow.Header.ClipMetadata)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Header_ClipMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.color_profile_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Header_ClipMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.Header.ClipMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.color_profile_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.frame_width_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.frame_readout_direction_) -
      reinterpret_cast<char*>(&_impl_.frame_width_)) + sizeof(_impl_.frame_readout_direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Header_ClipMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 0, 58, 2> Header_ClipMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Header_ClipMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 frame_width = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_ClipMetadata, _impl_.frame_width_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_width_)}},
    // uint32 frame_height = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_ClipMetadata, _impl_.frame_height_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_height_)}},
    // float duration_us = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.duration_us_)}},
    // float record_frame_rate = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.record_frame_rate_)}},
    // float sensor_frame_rate = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.sensor_frame_rate_)}},
    // float file_frame_rate = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.file_frame_rate_)}},
    // int32 rotation_degrees = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_ClipMetadata, _impl_.rotation_degrees_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.rotation_degrees_)}},
    // uint32 imu_sample_rate = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_ClipMetadata, _impl_.imu_sample_rate_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.imu_sample_rate_)}},
    // optional string color_profile = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 0, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.color_profile_)}},
    // float pixel_aspect_ratio = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.pixel_aspect_ratio_)}},
    // float frame_readout_time_us = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_readout_time_us_)}},
    // .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Header_ClipMetadata, _impl_.frame_readout_direction_), 63>(),
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_readout_direction_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 frame_width = 1;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_width_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 frame_height = 2;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_height_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // float duration_us = 3;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.duration_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float record_frame_rate = 4;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.record_frame_rate_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float sensor_frame_rate = 5;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.sensor_frame_rate_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float file_frame_rate = 6;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.file_frame_rate_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 rotation_degrees = 7;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.rotation_degrees_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // uint32 imu_sample_rate = 8;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.imu_sample_rate_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // optional string color_profile = 9;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.color_profile_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float pixel_aspect_ratio = 10;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.pixel_aspect_ratio_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float frame_readout_time_us = 11;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_readout_time_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
    {PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_readout_direction_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\34\0\0\0\0\0\0\0\0\15\0\0\0\0\0\0"
    "gyroflow.Header.ClipMetadata"
    "color_profile"
  }},
};

::uint8_t* Header_ClipMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.Header.ClipMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 frame_width = 1;
  if (this->_internal_frame_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_frame_width(), target);
  }

  // uint32 frame_height = 2;
  if (this->_internal_frame_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_frame_height(), target);
  }

  // float duration_us = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration_us = this->_internal_duration_us();
  ::uint32_t raw_duration_us;
  memcpy(&raw_duration_us, &tmp_duration_us, sizeof(tmp_duration_us));
  if (raw_duration_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_duration_us(), target);
  }

  // float record_frame_rate = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_record_frame_rate = this->_internal_record_frame_rate();
  ::uint32_t raw_record_frame_rate;
  memcpy(&raw_record_frame_rate, &tmp_record_frame_rate, sizeof(tmp_record_frame_rate));
  if (raw_record_frame_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_record_frame_rate(), target);
  }

  // float sensor_frame_rate = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_sensor_frame_rate = this->_internal_sensor_frame_rate();
  ::uint32_t raw_sensor_frame_rate;
  memcpy(&raw_sensor_frame_rate, &tmp_sensor_frame_rate, sizeof(tmp_sensor_frame_rate));
  if (raw_sensor_frame_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_sensor_frame_rate(), target);
  }

  // float file_frame_rate = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_file_frame_rate = this->_internal_file_frame_rate();
  ::uint32_t raw_file_frame_rate;
  memcpy(&raw_file_frame_rate, &tmp_file_frame_rate, sizeof(tmp_file_frame_rate));
  if (raw_file_frame_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_file_frame_rate(), target);
  }

  // int32 rotation_degrees = 7;
  if (this->_internal_rotation_degrees() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_rotation_degrees(), target);
  }

  // uint32 imu_sample_rate = 8;
  if (this->_internal_imu_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_imu_sample_rate(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string color_profile = 9;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_color_profile();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "gyroflow.Header.ClipMetadata.color_profile");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // float pixel_aspect_ratio = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pixel_aspect_ratio = this->_internal_pixel_aspect_ratio();
  ::uint32_t raw_pixel_aspect_ratio;
  memcpy(&raw_pixel_aspect_ratio, &tmp_pixel_aspect_ratio, sizeof(tmp_pixel_aspect_ratio));
  if (raw_pixel_aspect_ratio != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_pixel_aspect_ratio(), target);
  }

  // float frame_readout_time_us = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_frame_readout_time_us = this->_internal_frame_readout_time_us();
  ::uint32_t raw_frame_readout_time_us;
  memcpy(&raw_frame_readout_time_us, &tmp_frame_readout_time_us, sizeof(tmp_frame_readout_time_us));
  if (raw_frame_readout_time_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_frame_readout_time_us(), target);
  }

  // .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
  if (this->_internal_frame_readout_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        12, this->_internal_frame_readout_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.Header.ClipMetadata)
  return target;
}

::size_t Header_ClipMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.Header.ClipMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string color_profile = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_color_profile());
  }

  // uint32 frame_width = 1;
  if (this->_internal_frame_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_frame_width());
  }

  // uint32 frame_height = 2;
  if (this->_internal_frame_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_frame_height());
  }

  // float duration_us = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration_us = this->_internal_duration_us();
  ::uint32_t raw_duration_us;
  memcpy(&raw_duration_us, &tmp_duration_us, sizeof(tmp_duration_us));
  if (raw_duration_us != 0) {
    total_size += 5;
  }

  // float record_frame_rate = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_record_frame_rate = this->_internal_record_frame_rate();
  ::uint32_t raw_record_frame_rate;
  memcpy(&raw_record_frame_rate, &tmp_record_frame_rate, sizeof(tmp_record_frame_rate));
  if (raw_record_frame_rate != 0) {
    total_size += 5;
  }

  // float sensor_frame_rate = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_sensor_frame_rate = this->_internal_sensor_frame_rate();
  ::uint32_t raw_sensor_frame_rate;
  memcpy(&raw_sensor_frame_rate, &tmp_sensor_frame_rate, sizeof(tmp_sensor_frame_rate));
  if (raw_sensor_frame_rate != 0) {
    total_size += 5;
  }

  // float file_frame_rate = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_file_frame_rate = this->_internal_file_frame_rate();
  ::uint32_t raw_file_frame_rate;
  memcpy(&raw_file_frame_rate, &tmp_file_frame_rate, sizeof(tmp_file_frame_rate));
  if (raw_file_frame_rate != 0) {
    total_size += 5;
  }

  // int32 rotation_degrees = 7;
  if (this->_internal_rotation_degrees() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_rotation_degrees());
  }

  // uint32 imu_sample_rate = 8;
  if (this->_internal_imu_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_imu_sample_rate());
  }

  // float pixel_aspect_ratio = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pixel_aspect_ratio = this->_internal_pixel_aspect_ratio();
  ::uint32_t raw_pixel_aspect_ratio;
  memcpy(&raw_pixel_aspect_ratio, &tmp_pixel_aspect_ratio, sizeof(tmp_pixel_aspect_ratio));
  if (raw_pixel_aspect_ratio != 0) {
    total_size += 5;
  }

  // float frame_readout_time_us = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_frame_readout_time_us = this->_internal_frame_readout_time_us();
  ::uint32_t raw_frame_readout_time_us;
  memcpy(&raw_frame_readout_time_us, &tmp_frame_readout_time_us, sizeof(tmp_frame_readout_time_us));
  if (raw_frame_readout_time_us != 0) {
    total_size += 5;
  }

  // .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
  if (this->_internal_frame_readout_direction() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_frame_readout_direction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Header_ClipMetadata::_class_data_ = {
    Header_ClipMetadata::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Header_ClipMetadata::GetClassData() const {
  return &_class_data_;
}

void Header_ClipMetadata::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Header_ClipMetadata*>(&to_msg);
  auto& from = static_cast<const Header_ClipMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.Header.ClipMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_color_profile(from._internal_color_profile());
  }
  if (from._internal_frame_width() != 0) {
    _this->_internal_set_frame_width(from._internal_frame_width());
  }
  if (from._internal_frame_height() != 0) {
    _this->_internal_set_frame_height(from._internal_frame_height());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration_us = from._internal_duration_us();
  ::uint32_t raw_duration_us;
  memcpy(&raw_duration_us, &tmp_duration_us, sizeof(tmp_duration_us));
  if (raw_duration_us != 0) {
    _this->_internal_set_duration_us(from._internal_duration_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_record_frame_rate = from._internal_record_frame_rate();
  ::uint32_t raw_record_frame_rate;
  memcpy(&raw_record_frame_rate, &tmp_record_frame_rate, sizeof(tmp_record_frame_rate));
  if (raw_record_frame_rate != 0) {
    _this->_internal_set_record_frame_rate(from._internal_record_frame_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_sensor_frame_rate = from._internal_sensor_frame_rate();
  ::uint32_t raw_sensor_frame_rate;
  memcpy(&raw_sensor_frame_rate, &tmp_sensor_frame_rate, sizeof(tmp_sensor_frame_rate));
  if (raw_sensor_frame_rate != 0) {
    _this->_internal_set_sensor_frame_rate(from._internal_sensor_frame_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_file_frame_rate = from._internal_file_frame_rate();
  ::uint32_t raw_file_frame_rate;
  memcpy(&raw_file_frame_rate, &tmp_file_frame_rate, sizeof(tmp_file_frame_rate));
  if (raw_file_frame_rate != 0) {
    _this->_internal_set_file_frame_rate(from._internal_file_frame_rate());
  }
  if (from._internal_rotation_degrees() != 0) {
    _this->_internal_set_rotation_degrees(from._internal_rotation_degrees());
  }
  if (from._internal_imu_sample_rate() != 0) {
    _this->_internal_set_imu_sample_rate(from._internal_imu_sample_rate());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_pixel_aspect_ratio = from._internal_pixel_aspect_ratio();
  ::uint32_t raw_pixel_aspect_ratio;
  memcpy(&raw_pixel_aspect_ratio, &tmp_pixel_aspect_ratio, sizeof(tmp_pixel_aspect_ratio));
  if (raw_pixel_aspect_ratio != 0) {
    _this->_internal_set_pixel_aspect_ratio(from._internal_pixel_aspect_ratio());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_frame_readout_time_us = from._internal_frame_readout_time_us();
  ::uint32_t raw_frame_readout_time_us;
  memcpy(&raw_frame_readout_time_us, &tmp_frame_readout_time_us, sizeof(tmp_frame_readout_time_us));
  if (raw_frame_readout_time_us != 0) {
    _this->_internal_set_frame_readout_time_us(from._internal_frame_readout_time_us());
  }
  if (from._internal_frame_readout_direction() != 0) {
    _this->_internal_set_frame_readout_direction(from._internal_frame_readout_direction());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Header_ClipMetadata::CopyFrom(const Header_ClipMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.Header.ClipMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Header_ClipMetadata::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Header_ClipMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Header_ClipMetadata::InternalSwap(Header_ClipMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.color_profile_, &other->_impl_.color_profile_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_readout_direction_)
      + sizeof(Header_ClipMetadata::_impl_.frame_readout_direction_)
      - PROTOBUF_FIELD_OFFSET(Header_ClipMetadata, _impl_.frame_width_)>(
          reinterpret_cast<char*>(&_impl_.frame_width_),
          reinterpret_cast<char*>(&other->_impl_.frame_width_));
}

::google::protobuf::Metadata Header_ClipMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[2]);
}
// ===================================================================

class Header::_Internal {
 public:
  using HasBits = decltype(std::declval<Header>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Header, _impl_._has_bits_);
  static const ::gyroflow::Header_CameraMetadata& camera(const Header* msg);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gyroflow::Header_ClipMetadata& clip(const Header* msg);
  static void set_has_clip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gyroflow::Header_CameraMetadata& Header::_Internal::camera(const Header* msg) {
  return *msg->_impl_.camera_;
}
const ::gyroflow::Header_ClipMetadata& Header::_Internal::clip(const Header* msg) {
  return *msg->_impl_.clip_;
}
Header::Header(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.Header)
}
inline PROTOBUF_NDEBUG_INLINE Header::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Header::Header(
    ::google::protobuf::Arena* arena,
    const Header& from)
    : ::google::protobuf::Message(arena) {
  Header* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.camera_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::gyroflow::Header_CameraMetadata>(arena, *from._impl_.camera_)
                : nullptr;
  _impl_.clip_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::gyroflow::Header_ClipMetadata>(arena, *from._impl_.clip_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:gyroflow.Header)
}
inline PROTOBUF_NDEBUG_INLINE Header::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Header::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, camera_),
           0,
           offsetof(Impl_, clip_) -
               offsetof(Impl_, camera_) +
               sizeof(Impl_::clip_));
}
Header::~Header() {
  // @@protoc_insertion_point(destructor:gyroflow.Header)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Header::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.camera_;
  delete _impl_.clip_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.Header)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.camera_ != nullptr);
      _impl_.camera_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.clip_ != nullptr);
      _impl_.clip_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Header::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> Header::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Header, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Header_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .gyroflow.Header.ClipMetadata clip = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Header, _impl_.clip_)}},
    // .gyroflow.Header.CameraMetadata camera = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Header, _impl_.camera_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .gyroflow.Header.CameraMetadata camera = 1;
    {PROTOBUF_FIELD_OFFSET(Header, _impl_.camera_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .gyroflow.Header.ClipMetadata clip = 2;
    {PROTOBUF_FIELD_OFFSET(Header, _impl_.clip_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::Header_CameraMetadata>()},
    {::_pbi::TcParser::GetTable<::gyroflow::Header_ClipMetadata>()},
  }}, {{
  }},
};

::uint8_t* Header::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.Header)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .gyroflow.Header.CameraMetadata camera = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::camera(this),
        _Internal::camera(this).GetCachedSize(), target, stream);
  }

  // .gyroflow.Header.ClipMetadata clip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::clip(this),
        _Internal::clip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.Header)
  return target;
}

::size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.Header)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .gyroflow.Header.CameraMetadata camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.camera_);
    }

    // .gyroflow.Header.ClipMetadata clip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.clip_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Header::_class_data_ = {
    Header::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Header::GetClassData() const {
  return &_class_data_;
}

void Header::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Header*>(&to_msg);
  auto& from = static_cast<const Header&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.Header)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_camera()->::gyroflow::Header_CameraMetadata::MergeFrom(
          from._internal_camera());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_clip()->::gyroflow::Header_ClipMetadata::MergeFrom(
          from._internal_clip());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Header::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Header::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Header::InternalSwap(Header* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header, _impl_.clip_)
      + sizeof(Header::_impl_.clip_)
      - PROTOBUF_FIELD_OFFSET(Header, _impl_.camera_)>(
          reinterpret_cast<char*>(&_impl_.camera_),
          reinterpret_cast<char*>(&other->_impl_.camera_));
}

::google::protobuf::Metadata Header::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[3]);
}
// ===================================================================

class FrameMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_._has_bits_);
  static void set_has_iso(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_exposure_time_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_white_balance_kelvin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_white_balance_tint(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_digital_zoom_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_shutter_speed_numerator(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shutter_speed_denumerator(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shutter_angle_degrees(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_crop_x(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_crop_y(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_crop_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_crop_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

FrameMetadata::FrameMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.FrameMetadata)
}
inline PROTOBUF_NDEBUG_INLINE FrameMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        lens_{visibility, arena, from.lens_},
        imu_{visibility, arena, from.imu_},
        quaternions_{visibility, arena, from.quaternions_},
        ois_{visibility, arena, from.ois_},
        ibis_{visibility, arena, from.ibis_},
        eis_{visibility, arena, from.eis_} {}

FrameMetadata::FrameMetadata(
    ::google::protobuf::Arena* arena,
    const FrameMetadata& from)
    : ::google::protobuf::Message(arena) {
  FrameMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_timestamp_us_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, start_timestamp_us_),
           offsetof(Impl_, crop_height_) -
               offsetof(Impl_, start_timestamp_us_) +
               sizeof(Impl_::crop_height_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.FrameMetadata)
}
inline PROTOBUF_NDEBUG_INLINE FrameMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        lens_{visibility, arena},
        imu_{visibility, arena},
        quaternions_{visibility, arena},
        ois_{visibility, arena},
        ibis_{visibility, arena},
        eis_{visibility, arena} {}

inline void FrameMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_timestamp_us_),
           0,
           offsetof(Impl_, crop_height_) -
               offsetof(Impl_, start_timestamp_us_) +
               sizeof(Impl_::crop_height_));
}
FrameMetadata::~FrameMetadata() {
  // @@protoc_insertion_point(destructor:gyroflow.FrameMetadata)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FrameMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void FrameMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.FrameMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lens_.Clear();
  _impl_.imu_.Clear();
  _impl_.quaternions_.Clear();
  _impl_.ois_.Clear();
  _impl_.ibis_.Clear();
  _impl_.eis_.Clear();
  ::memset(&_impl_.start_timestamp_us_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.frame_number_) -
      reinterpret_cast<char*>(&_impl_.start_timestamp_us_)) + sizeof(_impl_.frame_number_));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.iso_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shutter_angle_degrees_) -
        reinterpret_cast<char*>(&_impl_.iso_)) + sizeof(_impl_.shutter_angle_degrees_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.crop_x_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.crop_height_) -
        reinterpret_cast<char*>(&_impl_.crop_x_)) + sizeof(_impl_.crop_height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* FrameMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 21, 6, 0, 2> FrameMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_._has_bits_),
    0, // no _extensions_
    21, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4292870144,  // skipmap
    offsetof(decltype(_table_), field_entries),
    21,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_FrameMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double start_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.start_timestamp_us_)}},
    // double end_timestamp_us = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.end_timestamp_us_)}},
    // uint32 frame_number = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FrameMetadata, _impl_.frame_number_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.frame_number_)}},
    // optional uint32 iso = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FrameMetadata, _impl_.iso_), 0>(),
     {32, 0, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.iso_)}},
    // optional float exposure_time_us = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 1, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.exposure_time_us_)}},
    // optional uint32 white_balance_kelvin = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FrameMetadata, _impl_.white_balance_kelvin_), 2>(),
     {48, 2, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.white_balance_kelvin_)}},
    // optional float white_balance_tint = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 3, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.white_balance_tint_)}},
    // optional float digital_zoom_ratio = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 4, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.digital_zoom_ratio_)}},
    // optional int32 shutter_speed_numerator = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FrameMetadata, _impl_.shutter_speed_numerator_), 5>(),
     {72, 5, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_speed_numerator_)}},
    // optional int32 shutter_speed_denumerator = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FrameMetadata, _impl_.shutter_speed_denumerator_), 6>(),
     {80, 6, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_speed_denumerator_)}},
    // optional float shutter_angle_degrees = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 7, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_angle_degrees_)}},
    // optional float crop_x = 12;
    {::_pbi::TcParser::FastF32S1,
     {101, 8, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_x_)}},
    // optional float crop_y = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 9, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_y_)}},
    // optional float crop_width = 14;
    {::_pbi::TcParser::FastF32S1,
     {117, 10, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_width_)}},
    // optional float crop_height = 15;
    {::_pbi::TcParser::FastF32S1,
     {125, 11, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_height_)}},
    // repeated .gyroflow.LensData lens = 16;
    {::_pbi::TcParser::FastMtR2,
     {386, 63, 0, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.lens_)}},
    // repeated .gyroflow.IMUData imu = 17;
    {::_pbi::TcParser::FastMtR2,
     {394, 63, 1, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.imu_)}},
    // repeated .gyroflow.QuaternionData quaternions = 18;
    {::_pbi::TcParser::FastMtR2,
     {402, 63, 2, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.quaternions_)}},
    // repeated .gyroflow.LensOISData ois = 19;
    {::_pbi::TcParser::FastMtR2,
     {410, 63, 3, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.ois_)}},
    // repeated .gyroflow.IBISData ibis = 20;
    {::_pbi::TcParser::FastMtR2,
     {418, 63, 4, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.ibis_)}},
    // repeated .gyroflow.EISData eis = 21;
    {::_pbi::TcParser::FastMtR2,
     {426, 63, 5, PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.eis_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double start_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.start_timestamp_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double end_timestamp_us = 2;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.end_timestamp_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // uint32 frame_number = 3;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.frame_number_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // optional uint32 iso = 4;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.iso_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float exposure_time_us = 5;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.exposure_time_us_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 white_balance_kelvin = 6;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.white_balance_kelvin_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float white_balance_tint = 7;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.white_balance_tint_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float digital_zoom_ratio = 8;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.digital_zoom_ratio_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional int32 shutter_speed_numerator = 9;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_speed_numerator_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 shutter_speed_denumerator = 10;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_speed_denumerator_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional float shutter_angle_degrees = 11;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.shutter_angle_degrees_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float crop_x = 12;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_x_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float crop_y = 13;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_y_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float crop_width = 14;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_width_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float crop_height = 15;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_height_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // repeated .gyroflow.LensData lens = 16;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.lens_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .gyroflow.IMUData imu = 17;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.imu_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .gyroflow.QuaternionData quaternions = 18;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.quaternions_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .gyroflow.LensOISData ois = 19;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.ois_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .gyroflow.IBISData ibis = 20;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.ibis_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .gyroflow.EISData eis = 21;
    {PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.eis_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::LensData>()},
    {::_pbi::TcParser::GetTable<::gyroflow::IMUData>()},
    {::_pbi::TcParser::GetTable<::gyroflow::QuaternionData>()},
    {::_pbi::TcParser::GetTable<::gyroflow::LensOISData>()},
    {::_pbi::TcParser::GetTable<::gyroflow::IBISData>()},
    {::_pbi::TcParser::GetTable<::gyroflow::EISData>()},
  }}, {{
  }},
};

::uint8_t* FrameMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.FrameMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double start_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_start_timestamp_us = this->_internal_start_timestamp_us();
  ::uint64_t raw_start_timestamp_us;
  memcpy(&raw_start_timestamp_us, &tmp_start_timestamp_us, sizeof(tmp_start_timestamp_us));
  if (raw_start_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_start_timestamp_us(), target);
  }

  // double end_timestamp_us = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_end_timestamp_us = this->_internal_end_timestamp_us();
  ::uint64_t raw_end_timestamp_us;
  memcpy(&raw_end_timestamp_us, &tmp_end_timestamp_us, sizeof(tmp_end_timestamp_us));
  if (raw_end_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_end_timestamp_us(), target);
  }

  // uint32 frame_number = 3;
  if (this->_internal_frame_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_frame_number(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 iso = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_iso(), target);
  }

  // optional float exposure_time_us = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_exposure_time_us(), target);
  }

  // optional uint32 white_balance_kelvin = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_white_balance_kelvin(), target);
  }

  // optional float white_balance_tint = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_white_balance_tint(), target);
  }

  // optional float digital_zoom_ratio = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_digital_zoom_ratio(), target);
  }

  // optional int32 shutter_speed_numerator = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<9>(
            stream, this->_internal_shutter_speed_numerator(), target);
  }

  // optional int32 shutter_speed_denumerator = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<10>(
            stream, this->_internal_shutter_speed_denumerator(), target);
  }

  // optional float shutter_angle_degrees = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_shutter_angle_degrees(), target);
  }

  // optional float crop_x = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_crop_x(), target);
  }

  // optional float crop_y = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_crop_y(), target);
  }

  // optional float crop_width = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_crop_width(), target);
  }

  // optional float crop_height = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_crop_height(), target);
  }

  // repeated .gyroflow.LensData lens = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lens_size()); i < n; i++) {
    const auto& repfield = this->_internal_lens().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gyroflow.IMUData imu = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_imu_size()); i < n; i++) {
    const auto& repfield = this->_internal_imu().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gyroflow.QuaternionData quaternions = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_quaternions_size()); i < n; i++) {
    const auto& repfield = this->_internal_quaternions().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gyroflow.LensOISData ois = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ois_size()); i < n; i++) {
    const auto& repfield = this->_internal_ois().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gyroflow.IBISData ibis = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ibis_size()); i < n; i++) {
    const auto& repfield = this->_internal_ibis().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gyroflow.EISData eis = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_eis_size()); i < n; i++) {
    const auto& repfield = this->_internal_eis().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.FrameMetadata)
  return target;
}

::size_t FrameMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.FrameMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gyroflow.LensData lens = 16;
  total_size += 2UL * this->_internal_lens_size();
  for (const auto& msg : this->_internal_lens()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .gyroflow.IMUData imu = 17;
  total_size += 2UL * this->_internal_imu_size();
  for (const auto& msg : this->_internal_imu()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .gyroflow.QuaternionData quaternions = 18;
  total_size += 2UL * this->_internal_quaternions_size();
  for (const auto& msg : this->_internal_quaternions()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .gyroflow.LensOISData ois = 19;
  total_size += 2UL * this->_internal_ois_size();
  for (const auto& msg : this->_internal_ois()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .gyroflow.IBISData ibis = 20;
  total_size += 2UL * this->_internal_ibis_size();
  for (const auto& msg : this->_internal_ibis()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .gyroflow.EISData eis = 21;
  total_size += 2UL * this->_internal_eis_size();
  for (const auto& msg : this->_internal_eis()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // double start_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_start_timestamp_us = this->_internal_start_timestamp_us();
  ::uint64_t raw_start_timestamp_us;
  memcpy(&raw_start_timestamp_us, &tmp_start_timestamp_us, sizeof(tmp_start_timestamp_us));
  if (raw_start_timestamp_us != 0) {
    total_size += 9;
  }

  // double end_timestamp_us = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_end_timestamp_us = this->_internal_end_timestamp_us();
  ::uint64_t raw_end_timestamp_us;
  memcpy(&raw_end_timestamp_us, &tmp_end_timestamp_us, sizeof(tmp_end_timestamp_us));
  if (raw_end_timestamp_us != 0) {
    total_size += 9;
  }

  // uint32 frame_number = 3;
  if (this->_internal_frame_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_frame_number());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 iso = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_iso());
    }

    // optional float exposure_time_us = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional uint32 white_balance_kelvin = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_white_balance_kelvin());
    }

    // optional float white_balance_tint = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // optional float digital_zoom_ratio = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // optional int32 shutter_speed_numerator = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_shutter_speed_numerator());
    }

    // optional int32 shutter_speed_denumerator = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_shutter_speed_denumerator());
    }

    // optional float shutter_angle_degrees = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float crop_x = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // optional float crop_y = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

    // optional float crop_width = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 5;
    }

    // optional float crop_height = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData FrameMetadata::_class_data_ = {
    FrameMetadata::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* FrameMetadata::GetClassData() const {
  return &_class_data_;
}

void FrameMetadata::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<FrameMetadata*>(&to_msg);
  auto& from = static_cast<const FrameMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.FrameMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_lens()->MergeFrom(
      from._internal_lens());
  _this->_internal_mutable_imu()->MergeFrom(
      from._internal_imu());
  _this->_internal_mutable_quaternions()->MergeFrom(
      from._internal_quaternions());
  _this->_internal_mutable_ois()->MergeFrom(
      from._internal_ois());
  _this->_internal_mutable_ibis()->MergeFrom(
      from._internal_ibis());
  _this->_internal_mutable_eis()->MergeFrom(
      from._internal_eis());
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_start_timestamp_us = from._internal_start_timestamp_us();
  ::uint64_t raw_start_timestamp_us;
  memcpy(&raw_start_timestamp_us, &tmp_start_timestamp_us, sizeof(tmp_start_timestamp_us));
  if (raw_start_timestamp_us != 0) {
    _this->_internal_set_start_timestamp_us(from._internal_start_timestamp_us());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_end_timestamp_us = from._internal_end_timestamp_us();
  ::uint64_t raw_end_timestamp_us;
  memcpy(&raw_end_timestamp_us, &tmp_end_timestamp_us, sizeof(tmp_end_timestamp_us));
  if (raw_end_timestamp_us != 0) {
    _this->_internal_set_end_timestamp_us(from._internal_end_timestamp_us());
  }
  if (from._internal_frame_number() != 0) {
    _this->_internal_set_frame_number(from._internal_frame_number());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.iso_ = from._impl_.iso_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.exposure_time_us_ = from._impl_.exposure_time_us_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.white_balance_kelvin_ = from._impl_.white_balance_kelvin_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.white_balance_tint_ = from._impl_.white_balance_tint_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.digital_zoom_ratio_ = from._impl_.digital_zoom_ratio_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.shutter_speed_numerator_ = from._impl_.shutter_speed_numerator_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shutter_speed_denumerator_ = from._impl_.shutter_speed_denumerator_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.shutter_angle_degrees_ = from._impl_.shutter_angle_degrees_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.crop_x_ = from._impl_.crop_x_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.crop_y_ = from._impl_.crop_y_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.crop_width_ = from._impl_.crop_width_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.crop_height_ = from._impl_.crop_height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FrameMetadata::CopyFrom(const FrameMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.FrameMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FrameMetadata::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* FrameMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void FrameMetadata::InternalSwap(FrameMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lens_.InternalSwap(&other->_impl_.lens_);
  _impl_.imu_.InternalSwap(&other->_impl_.imu_);
  _impl_.quaternions_.InternalSwap(&other->_impl_.quaternions_);
  _impl_.ois_.InternalSwap(&other->_impl_.ois_);
  _impl_.ibis_.InternalSwap(&other->_impl_.ibis_);
  _impl_.eis_.InternalSwap(&other->_impl_.eis_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.crop_height_)
      + sizeof(FrameMetadata::_impl_.crop_height_)
      - PROTOBUF_FIELD_OFFSET(FrameMetadata, _impl_.start_timestamp_us_)>(
          reinterpret_cast<char*>(&_impl_.start_timestamp_us_),
          reinterpret_cast<char*>(&other->_impl_.start_timestamp_us_));
}

::google::protobuf::Metadata FrameMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[4]);
}
// ===================================================================

class LensData::_Internal {
 public:
  using HasBits = decltype(std::declval<LensData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LensData, _impl_._has_bits_);
  static void set_has_focal_length_mm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_f_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_focus_distance_mm(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LensData::LensData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.LensData)
}
inline PROTOBUF_NDEBUG_INLINE LensData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        distortion_coefficients_{visibility, arena, from.distortion_coefficients_},
        camera_intrinsic_matrix_{visibility, arena, from.camera_intrinsic_matrix_} {}

LensData::LensData(
    ::google::protobuf::Arena* arena,
    const LensData& from)
    : ::google::protobuf::Message(arena) {
  LensData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, distortion_model_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, distortion_model_),
           offsetof(Impl_, focus_distance_mm_) -
               offsetof(Impl_, distortion_model_) +
               sizeof(Impl_::focus_distance_mm_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.LensData)
}
inline PROTOBUF_NDEBUG_INLINE LensData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        distortion_coefficients_{visibility, arena},
        camera_intrinsic_matrix_{visibility, arena} {}

inline void LensData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, distortion_model_),
           0,
           offsetof(Impl_, focus_distance_mm_) -
               offsetof(Impl_, distortion_model_) +
               sizeof(Impl_::focus_distance_mm_));
}
LensData::~LensData() {
  // @@protoc_insertion_point(destructor:gyroflow.LensData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LensData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LensData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.LensData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.distortion_coefficients_.Clear();
  _impl_.camera_intrinsic_matrix_.Clear();
  _impl_.distortion_model_ = 0;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.focal_length_mm_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.focus_distance_mm_) -
        reinterpret_cast<char*>(&_impl_.focal_length_mm_)) + sizeof(_impl_.focus_distance_mm_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LensData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> LensData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LensData, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LensData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .gyroflow.LensData.DistortionModel distortion_model = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LensData, _impl_.distortion_model_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.distortion_model_)}},
    // repeated float distortion_coefficients = 2;
    {::_pbi::TcParser::FastF32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.distortion_coefficients_)}},
    // repeated float camera_intrinsic_matrix = 3;
    {::_pbi::TcParser::FastF32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.camera_intrinsic_matrix_)}},
    // optional float focal_length_mm = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 0, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.focal_length_mm_)}},
    // optional float f_number = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 1, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.f_number_)}},
    // optional float focus_distance_mm = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 2, 0, PROTOBUF_FIELD_OFFSET(LensData, _impl_.focus_distance_mm_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .gyroflow.LensData.DistortionModel distortion_model = 1;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.distortion_model_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated float distortion_coefficients = 2;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.distortion_coefficients_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // repeated float camera_intrinsic_matrix = 3;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.camera_intrinsic_matrix_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // optional float focal_length_mm = 4;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.focal_length_mm_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float f_number = 5;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.f_number_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float focus_distance_mm = 6;
    {PROTOBUF_FIELD_OFFSET(LensData, _impl_.focus_distance_mm_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* LensData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.LensData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .gyroflow.LensData.DistortionModel distortion_model = 1;
  if (this->_internal_distortion_model() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_distortion_model(), target);
  }

  // repeated float distortion_coefficients = 2;
  if (this->_internal_distortion_coefficients_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_distortion_coefficients(), target);
  }

  // repeated float camera_intrinsic_matrix = 3;
  if (this->_internal_camera_intrinsic_matrix_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_camera_intrinsic_matrix(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional float focal_length_mm = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_focal_length_mm(), target);
  }

  // optional float f_number = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_f_number(), target);
  }

  // optional float focus_distance_mm = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_focus_distance_mm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.LensData)
  return target;
}

::size_t LensData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.LensData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float distortion_coefficients = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_distortion_coefficients_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated float camera_intrinsic_matrix = 3;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_camera_intrinsic_matrix_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // .gyroflow.LensData.DistortionModel distortion_model = 1;
  if (this->_internal_distortion_model() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_distortion_model());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float focal_length_mm = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // optional float f_number = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional float focus_distance_mm = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LensData::_class_data_ = {
    LensData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LensData::GetClassData() const {
  return &_class_data_;
}

void LensData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LensData*>(&to_msg);
  auto& from = static_cast<const LensData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.LensData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_distortion_coefficients()->MergeFrom(from._internal_distortion_coefficients());
  _this->_internal_mutable_camera_intrinsic_matrix()->MergeFrom(from._internal_camera_intrinsic_matrix());
  if (from._internal_distortion_model() != 0) {
    _this->_internal_set_distortion_model(from._internal_distortion_model());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.focal_length_mm_ = from._impl_.focal_length_mm_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.f_number_ = from._impl_.f_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.focus_distance_mm_ = from._impl_.focus_distance_mm_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LensData::CopyFrom(const LensData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.LensData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LensData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LensData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LensData::InternalSwap(LensData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.distortion_coefficients_.InternalSwap(&other->_impl_.distortion_coefficients_);
  _impl_.camera_intrinsic_matrix_.InternalSwap(&other->_impl_.camera_intrinsic_matrix_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LensData, _impl_.focus_distance_mm_)
      + sizeof(LensData::_impl_.focus_distance_mm_)
      - PROTOBUF_FIELD_OFFSET(LensData, _impl_.distortion_model_)>(
          reinterpret_cast<char*>(&_impl_.distortion_model_),
          reinterpret_cast<char*>(&other->_impl_.distortion_model_));
}

::google::protobuf::Metadata LensData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[5]);
}
// ===================================================================

class IMUData::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IMUData, _impl_._has_bits_);
  static void set_has_magnetometer_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_magnetometer_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_magnetometer_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IMUData::IMUData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.IMUData)
}
IMUData::IMUData(
    ::google::protobuf::Arena* arena, const IMUData& from)
    : IMUData(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE IMUData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void IMUData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sample_timestamp_us_),
           0,
           offsetof(Impl_, magnetometer_z_) -
               offsetof(Impl_, sample_timestamp_us_) +
               sizeof(Impl_::magnetometer_z_));
}
IMUData::~IMUData() {
  // @@protoc_insertion_point(destructor:gyroflow.IMUData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void IMUData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IMUData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.IMUData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sample_timestamp_us_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.accelerometer_z_) -
      reinterpret_cast<char*>(&_impl_.sample_timestamp_us_)) + sizeof(_impl_.accelerometer_z_));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.magnetometer_x_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.magnetometer_z_) -
        reinterpret_cast<char*>(&_impl_.magnetometer_x_)) + sizeof(_impl_.magnetometer_z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* IMUData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 0, 0, 2> IMUData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IMUData, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_IMUData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double sample_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.sample_timestamp_us_)}},
    // float gyroscope_x = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_x_)}},
    // float gyroscope_y = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_y_)}},
    // float gyroscope_z = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_z_)}},
    // float accelerometer_x = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_x_)}},
    // float accelerometer_y = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_y_)}},
    // float accelerometer_z = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_z_)}},
    // optional float magnetometer_x = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 0, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_x_)}},
    // optional float magnetometer_y = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 1, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_y_)}},
    // optional float magnetometer_z = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 2, 0, PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_z_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double sample_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.sample_timestamp_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // float gyroscope_x = 2;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_x_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float gyroscope_y = 3;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_y_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float gyroscope_z = 4;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.gyroscope_z_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float accelerometer_x = 5;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_x_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float accelerometer_y = 6;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_y_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float accelerometer_z = 7;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.accelerometer_z_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // optional float magnetometer_x = 8;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float magnetometer_y = 9;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_y_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float magnetometer_z = 10;
    {PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_z_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* IMUData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.IMUData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_sample_timestamp_us(), target);
  }

  // float gyroscope_x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_x = this->_internal_gyroscope_x();
  ::uint32_t raw_gyroscope_x;
  memcpy(&raw_gyroscope_x, &tmp_gyroscope_x, sizeof(tmp_gyroscope_x));
  if (raw_gyroscope_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_gyroscope_x(), target);
  }

  // float gyroscope_y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_y = this->_internal_gyroscope_y();
  ::uint32_t raw_gyroscope_y;
  memcpy(&raw_gyroscope_y, &tmp_gyroscope_y, sizeof(tmp_gyroscope_y));
  if (raw_gyroscope_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_gyroscope_y(), target);
  }

  // float gyroscope_z = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_z = this->_internal_gyroscope_z();
  ::uint32_t raw_gyroscope_z;
  memcpy(&raw_gyroscope_z, &tmp_gyroscope_z, sizeof(tmp_gyroscope_z));
  if (raw_gyroscope_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_gyroscope_z(), target);
  }

  // float accelerometer_x = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_x = this->_internal_accelerometer_x();
  ::uint32_t raw_accelerometer_x;
  memcpy(&raw_accelerometer_x, &tmp_accelerometer_x, sizeof(tmp_accelerometer_x));
  if (raw_accelerometer_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_accelerometer_x(), target);
  }

  // float accelerometer_y = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_y = this->_internal_accelerometer_y();
  ::uint32_t raw_accelerometer_y;
  memcpy(&raw_accelerometer_y, &tmp_accelerometer_y, sizeof(tmp_accelerometer_y));
  if (raw_accelerometer_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_accelerometer_y(), target);
  }

  // float accelerometer_z = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_z = this->_internal_accelerometer_z();
  ::uint32_t raw_accelerometer_z;
  memcpy(&raw_accelerometer_z, &tmp_accelerometer_z, sizeof(tmp_accelerometer_z));
  if (raw_accelerometer_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_accelerometer_z(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional float magnetometer_x = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_magnetometer_x(), target);
  }

  // optional float magnetometer_y = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_magnetometer_y(), target);
  }

  // optional float magnetometer_z = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_magnetometer_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.IMUData)
  return target;
}

::size_t IMUData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.IMUData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    total_size += 9;
  }

  // float gyroscope_x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_x = this->_internal_gyroscope_x();
  ::uint32_t raw_gyroscope_x;
  memcpy(&raw_gyroscope_x, &tmp_gyroscope_x, sizeof(tmp_gyroscope_x));
  if (raw_gyroscope_x != 0) {
    total_size += 5;
  }

  // float gyroscope_y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_y = this->_internal_gyroscope_y();
  ::uint32_t raw_gyroscope_y;
  memcpy(&raw_gyroscope_y, &tmp_gyroscope_y, sizeof(tmp_gyroscope_y));
  if (raw_gyroscope_y != 0) {
    total_size += 5;
  }

  // float gyroscope_z = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_z = this->_internal_gyroscope_z();
  ::uint32_t raw_gyroscope_z;
  memcpy(&raw_gyroscope_z, &tmp_gyroscope_z, sizeof(tmp_gyroscope_z));
  if (raw_gyroscope_z != 0) {
    total_size += 5;
  }

  // float accelerometer_x = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_x = this->_internal_accelerometer_x();
  ::uint32_t raw_accelerometer_x;
  memcpy(&raw_accelerometer_x, &tmp_accelerometer_x, sizeof(tmp_accelerometer_x));
  if (raw_accelerometer_x != 0) {
    total_size += 5;
  }

  // float accelerometer_y = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_y = this->_internal_accelerometer_y();
  ::uint32_t raw_accelerometer_y;
  memcpy(&raw_accelerometer_y, &tmp_accelerometer_y, sizeof(tmp_accelerometer_y));
  if (raw_accelerometer_y != 0) {
    total_size += 5;
  }

  // float accelerometer_z = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_z = this->_internal_accelerometer_z();
  ::uint32_t raw_accelerometer_z;
  memcpy(&raw_accelerometer_z, &tmp_accelerometer_z, sizeof(tmp_accelerometer_z));
  if (raw_accelerometer_z != 0) {
    total_size += 5;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float magnetometer_x = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // optional float magnetometer_y = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional float magnetometer_z = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData IMUData::_class_data_ = {
    IMUData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* IMUData::GetClassData() const {
  return &_class_data_;
}

void IMUData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<IMUData*>(&to_msg);
  auto& from = static_cast<const IMUData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.IMUData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = from._internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    _this->_internal_set_sample_timestamp_us(from._internal_sample_timestamp_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_x = from._internal_gyroscope_x();
  ::uint32_t raw_gyroscope_x;
  memcpy(&raw_gyroscope_x, &tmp_gyroscope_x, sizeof(tmp_gyroscope_x));
  if (raw_gyroscope_x != 0) {
    _this->_internal_set_gyroscope_x(from._internal_gyroscope_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_y = from._internal_gyroscope_y();
  ::uint32_t raw_gyroscope_y;
  memcpy(&raw_gyroscope_y, &tmp_gyroscope_y, sizeof(tmp_gyroscope_y));
  if (raw_gyroscope_y != 0) {
    _this->_internal_set_gyroscope_y(from._internal_gyroscope_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gyroscope_z = from._internal_gyroscope_z();
  ::uint32_t raw_gyroscope_z;
  memcpy(&raw_gyroscope_z, &tmp_gyroscope_z, sizeof(tmp_gyroscope_z));
  if (raw_gyroscope_z != 0) {
    _this->_internal_set_gyroscope_z(from._internal_gyroscope_z());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_x = from._internal_accelerometer_x();
  ::uint32_t raw_accelerometer_x;
  memcpy(&raw_accelerometer_x, &tmp_accelerometer_x, sizeof(tmp_accelerometer_x));
  if (raw_accelerometer_x != 0) {
    _this->_internal_set_accelerometer_x(from._internal_accelerometer_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_y = from._internal_accelerometer_y();
  ::uint32_t raw_accelerometer_y;
  memcpy(&raw_accelerometer_y, &tmp_accelerometer_y, sizeof(tmp_accelerometer_y));
  if (raw_accelerometer_y != 0) {
    _this->_internal_set_accelerometer_y(from._internal_accelerometer_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_accelerometer_z = from._internal_accelerometer_z();
  ::uint32_t raw_accelerometer_z;
  memcpy(&raw_accelerometer_z, &tmp_accelerometer_z, sizeof(tmp_accelerometer_z));
  if (raw_accelerometer_z != 0) {
    _this->_internal_set_accelerometer_z(from._internal_accelerometer_z());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.magnetometer_x_ = from._impl_.magnetometer_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.magnetometer_y_ = from._impl_.magnetometer_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.magnetometer_z_ = from._impl_.magnetometer_z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void IMUData::CopyFrom(const IMUData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.IMUData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IMUData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IMUData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IMUData::InternalSwap(IMUData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMUData, _impl_.magnetometer_z_)
      + sizeof(IMUData::_impl_.magnetometer_z_)
      - PROTOBUF_FIELD_OFFSET(IMUData, _impl_.sample_timestamp_us_)>(
          reinterpret_cast<char*>(&_impl_.sample_timestamp_us_),
          reinterpret_cast<char*>(&other->_impl_.sample_timestamp_us_));
}

::google::protobuf::Metadata IMUData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[6]);
}
// ===================================================================

class Quaternion::_Internal {
 public:
};

Quaternion::Quaternion(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.Quaternion)
}
Quaternion::Quaternion(
    ::google::protobuf::Arena* arena, const Quaternion& from)
    : Quaternion(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Quaternion::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, w_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, w_) +
               sizeof(Impl_::z_));
}
Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:gyroflow.Quaternion)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Quaternion::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.Quaternion)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.w_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.w_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> Quaternion::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Quaternion_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float z = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_)}},
    // float w = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)}},
    // float x = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)}},
    // float y = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.y_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float w = 1;
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float x = 2;
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 3;
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z = 4;
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Quaternion::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.Quaternion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float w = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_w(), target);
  }

  // float x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_x(), target);
  }

  // float y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_y(), target);
  }

  // float z = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.Quaternion)
  return target;
}

::size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.Quaternion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float w = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 5;
  }

  // float x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float z = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Quaternion::_class_data_ = {
    Quaternion::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Quaternion::GetClassData() const {
  return &_class_data_;
}

void Quaternion::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.Quaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Quaternion::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Quaternion::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Quaternion::InternalSwap(Quaternion* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_)
      + sizeof(Quaternion::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)>(
          reinterpret_cast<char*>(&_impl_.w_),
          reinterpret_cast<char*>(&other->_impl_.w_));
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[7]);
}
// ===================================================================

class QuaternionData::_Internal {
 public:
  using HasBits = decltype(std::declval<QuaternionData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_._has_bits_);
  static const ::gyroflow::Quaternion& quat(const QuaternionData* msg);
  static void set_has_quat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::gyroflow::Quaternion& QuaternionData::_Internal::quat(const QuaternionData* msg) {
  return *msg->_impl_.quat_;
}
QuaternionData::QuaternionData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.QuaternionData)
}
inline PROTOBUF_NDEBUG_INLINE QuaternionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

QuaternionData::QuaternionData(
    ::google::protobuf::Arena* arena,
    const QuaternionData& from)
    : ::google::protobuf::Message(arena) {
  QuaternionData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.quat_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::gyroflow::Quaternion>(arena, *from._impl_.quat_)
                : nullptr;
  _impl_.sample_timestamp_us_ = from._impl_.sample_timestamp_us_;

  // @@protoc_insertion_point(copy_constructor:gyroflow.QuaternionData)
}
inline PROTOBUF_NDEBUG_INLINE QuaternionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void QuaternionData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, quat_),
           0,
           offsetof(Impl_, sample_timestamp_us_) -
               offsetof(Impl_, quat_) +
               sizeof(Impl_::sample_timestamp_us_));
}
QuaternionData::~QuaternionData() {
  // @@protoc_insertion_point(destructor:gyroflow.QuaternionData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void QuaternionData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.quat_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void QuaternionData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.QuaternionData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.quat_ != nullptr);
    _impl_.quat_->Clear();
  }
  _impl_.sample_timestamp_us_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* QuaternionData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> QuaternionData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_QuaternionData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .gyroflow.Quaternion quat = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.quat_)}},
    // double sample_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.sample_timestamp_us_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double sample_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.sample_timestamp_us_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .gyroflow.Quaternion quat = 2;
    {PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.quat_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::Quaternion>()},
  }}, {{
  }},
};

::uint8_t* QuaternionData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.QuaternionData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_sample_timestamp_us(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .gyroflow.Quaternion quat = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::quat(this),
        _Internal::quat(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.QuaternionData)
  return target;
}

::size_t QuaternionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.QuaternionData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .gyroflow.Quaternion quat = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.quat_);
  }

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData QuaternionData::_class_data_ = {
    QuaternionData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* QuaternionData::GetClassData() const {
  return &_class_data_;
}

void QuaternionData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<QuaternionData*>(&to_msg);
  auto& from = static_cast<const QuaternionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.QuaternionData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_quat()->::gyroflow::Quaternion::MergeFrom(
        from._internal_quat());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = from._internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    _this->_internal_set_sample_timestamp_us(from._internal_sample_timestamp_us());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QuaternionData::CopyFrom(const QuaternionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.QuaternionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool QuaternionData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* QuaternionData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void QuaternionData::InternalSwap(QuaternionData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.sample_timestamp_us_)
      + sizeof(QuaternionData::_impl_.sample_timestamp_us_)
      - PROTOBUF_FIELD_OFFSET(QuaternionData, _impl_.quat_)>(
          reinterpret_cast<char*>(&_impl_.quat_),
          reinterpret_cast<char*>(&other->_impl_.quat_));
}

::google::protobuf::Metadata QuaternionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[8]);
}
// ===================================================================

class LensOISData::_Internal {
 public:
};

LensOISData::LensOISData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.LensOISData)
}
LensOISData::LensOISData(
    ::google::protobuf::Arena* arena, const LensOISData& from)
    : LensOISData(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE LensOISData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LensOISData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sample_timestamp_us_),
           0,
           offsetof(Impl_, y_) -
               offsetof(Impl_, sample_timestamp_us_) +
               sizeof(Impl_::y_));
}
LensOISData::~LensOISData() {
  // @@protoc_insertion_point(destructor:gyroflow.LensOISData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LensOISData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LensOISData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.LensOISData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sample_timestamp_us_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.sample_timestamp_us_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LensOISData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> LensOISData::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LensOISData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double sample_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.sample_timestamp_us_)}},
    // float x = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.x_)}},
    // float y = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.y_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double sample_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.sample_timestamp_us_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // float x = 2;
    {PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 3;
    {PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* LensOISData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.LensOISData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_sample_timestamp_us(), target);
  }

  // float x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_x(), target);
  }

  // float y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.LensOISData)
  return target;
}

::size_t LensOISData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.LensOISData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    total_size += 9;
  }

  // float x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LensOISData::_class_data_ = {
    LensOISData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LensOISData::GetClassData() const {
  return &_class_data_;
}

void LensOISData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LensOISData*>(&to_msg);
  auto& from = static_cast<const LensOISData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.LensOISData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = from._internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    _this->_internal_set_sample_timestamp_us(from._internal_sample_timestamp_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LensOISData::CopyFrom(const LensOISData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.LensOISData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LensOISData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LensOISData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LensOISData::InternalSwap(LensOISData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.y_)
      + sizeof(LensOISData::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(LensOISData, _impl_.sample_timestamp_us_)>(
          reinterpret_cast<char*>(&_impl_.sample_timestamp_us_),
          reinterpret_cast<char*>(&other->_impl_.sample_timestamp_us_));
}

::google::protobuf::Metadata LensOISData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[9]);
}
// ===================================================================

class IBISData::_Internal {
 public:
};

IBISData::IBISData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.IBISData)
}
IBISData::IBISData(
    ::google::protobuf::Arena* arena, const IBISData& from)
    : IBISData(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE IBISData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void IBISData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sample_timestamp_us_),
           0,
           offsetof(Impl_, roll_angle_degrees_) -
               offsetof(Impl_, sample_timestamp_us_) +
               sizeof(Impl_::roll_angle_degrees_));
}
IBISData::~IBISData() {
  // @@protoc_insertion_point(destructor:gyroflow.IBISData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void IBISData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IBISData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.IBISData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sample_timestamp_us_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.roll_angle_degrees_) -
      reinterpret_cast<char*>(&_impl_.sample_timestamp_us_)) + sizeof(_impl_.roll_angle_degrees_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* IBISData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> IBISData::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_IBISData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float roll_angle_degrees = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(IBISData, _impl_.roll_angle_degrees_)}},
    // double sample_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(IBISData, _impl_.sample_timestamp_us_)}},
    // float shift_x = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(IBISData, _impl_.shift_x_)}},
    // float shift_y = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(IBISData, _impl_.shift_y_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double sample_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(IBISData, _impl_.sample_timestamp_us_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // float shift_x = 2;
    {PROTOBUF_FIELD_OFFSET(IBISData, _impl_.shift_x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float shift_y = 3;
    {PROTOBUF_FIELD_OFFSET(IBISData, _impl_.shift_y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float roll_angle_degrees = 4;
    {PROTOBUF_FIELD_OFFSET(IBISData, _impl_.roll_angle_degrees_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* IBISData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.IBISData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_sample_timestamp_us(), target);
  }

  // float shift_x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_x = this->_internal_shift_x();
  ::uint32_t raw_shift_x;
  memcpy(&raw_shift_x, &tmp_shift_x, sizeof(tmp_shift_x));
  if (raw_shift_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_shift_x(), target);
  }

  // float shift_y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_y = this->_internal_shift_y();
  ::uint32_t raw_shift_y;
  memcpy(&raw_shift_y, &tmp_shift_y, sizeof(tmp_shift_y));
  if (raw_shift_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_shift_y(), target);
  }

  // float roll_angle_degrees = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_roll_angle_degrees = this->_internal_roll_angle_degrees();
  ::uint32_t raw_roll_angle_degrees;
  memcpy(&raw_roll_angle_degrees, &tmp_roll_angle_degrees, sizeof(tmp_roll_angle_degrees));
  if (raw_roll_angle_degrees != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_roll_angle_degrees(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.IBISData)
  return target;
}

::size_t IBISData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.IBISData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double sample_timestamp_us = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = this->_internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    total_size += 9;
  }

  // float shift_x = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_x = this->_internal_shift_x();
  ::uint32_t raw_shift_x;
  memcpy(&raw_shift_x, &tmp_shift_x, sizeof(tmp_shift_x));
  if (raw_shift_x != 0) {
    total_size += 5;
  }

  // float shift_y = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_y = this->_internal_shift_y();
  ::uint32_t raw_shift_y;
  memcpy(&raw_shift_y, &tmp_shift_y, sizeof(tmp_shift_y));
  if (raw_shift_y != 0) {
    total_size += 5;
  }

  // float roll_angle_degrees = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_roll_angle_degrees = this->_internal_roll_angle_degrees();
  ::uint32_t raw_roll_angle_degrees;
  memcpy(&raw_roll_angle_degrees, &tmp_roll_angle_degrees, sizeof(tmp_roll_angle_degrees));
  if (raw_roll_angle_degrees != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData IBISData::_class_data_ = {
    IBISData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* IBISData::GetClassData() const {
  return &_class_data_;
}

void IBISData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<IBISData*>(&to_msg);
  auto& from = static_cast<const IBISData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.IBISData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_sample_timestamp_us = from._internal_sample_timestamp_us();
  ::uint64_t raw_sample_timestamp_us;
  memcpy(&raw_sample_timestamp_us, &tmp_sample_timestamp_us, sizeof(tmp_sample_timestamp_us));
  if (raw_sample_timestamp_us != 0) {
    _this->_internal_set_sample_timestamp_us(from._internal_sample_timestamp_us());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_x = from._internal_shift_x();
  ::uint32_t raw_shift_x;
  memcpy(&raw_shift_x, &tmp_shift_x, sizeof(tmp_shift_x));
  if (raw_shift_x != 0) {
    _this->_internal_set_shift_x(from._internal_shift_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_shift_y = from._internal_shift_y();
  ::uint32_t raw_shift_y;
  memcpy(&raw_shift_y, &tmp_shift_y, sizeof(tmp_shift_y));
  if (raw_shift_y != 0) {
    _this->_internal_set_shift_y(from._internal_shift_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_roll_angle_degrees = from._internal_roll_angle_degrees();
  ::uint32_t raw_roll_angle_degrees;
  memcpy(&raw_roll_angle_degrees, &tmp_roll_angle_degrees, sizeof(tmp_roll_angle_degrees));
  if (raw_roll_angle_degrees != 0) {
    _this->_internal_set_roll_angle_degrees(from._internal_roll_angle_degrees());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void IBISData::CopyFrom(const IBISData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.IBISData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IBISData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IBISData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IBISData::InternalSwap(IBISData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IBISData, _impl_.roll_angle_degrees_)
      + sizeof(IBISData::_impl_.roll_angle_degrees_)
      - PROTOBUF_FIELD_OFFSET(IBISData, _impl_.sample_timestamp_us_)>(
          reinterpret_cast<char*>(&_impl_.sample_timestamp_us_),
          reinterpret_cast<char*>(&other->_impl_.sample_timestamp_us_));
}

::google::protobuf::Metadata IBISData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[10]);
}
// ===================================================================

class EISData::_Internal {
 public:
  using HasBits = decltype(std::declval<EISData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EISData, _impl_._has_bits_);
  static void set_has_sample_timestamp_us(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::gyroflow::Quaternion& quaternion(const EISData* msg);
  static void set_has_quaternion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gyroflow::MeshWarpData& mesh_warp(const EISData* msg);
  static void set_has_mesh_warp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gyroflow::Quaternion& EISData::_Internal::quaternion(const EISData* msg) {
  return *msg->_impl_.quaternion_;
}
const ::gyroflow::MeshWarpData& EISData::_Internal::mesh_warp(const EISData* msg) {
  return *msg->_impl_.mesh_warp_;
}
EISData::EISData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.EISData)
}
inline PROTOBUF_NDEBUG_INLINE EISData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        matrix_4x4_{visibility, arena, from.matrix_4x4_} {}

EISData::EISData(
    ::google::protobuf::Arena* arena,
    const EISData& from)
    : ::google::protobuf::Message(arena) {
  EISData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.quaternion_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::gyroflow::Quaternion>(arena, *from._impl_.quaternion_)
                : nullptr;
  _impl_.mesh_warp_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::gyroflow::MeshWarpData>(arena, *from._impl_.mesh_warp_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sample_timestamp_us_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, sample_timestamp_us_),
           offsetof(Impl_, type_) -
               offsetof(Impl_, sample_timestamp_us_) +
               sizeof(Impl_::type_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.EISData)
}
inline PROTOBUF_NDEBUG_INLINE EISData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        matrix_4x4_{visibility, arena} {}

inline void EISData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, quaternion_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, quaternion_) +
               sizeof(Impl_::type_));
}
EISData::~EISData() {
  // @@protoc_insertion_point(destructor:gyroflow.EISData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EISData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.quaternion_;
  delete _impl_.mesh_warp_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void EISData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.EISData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matrix_4x4_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.quaternion_ != nullptr);
      _impl_.quaternion_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.mesh_warp_ != nullptr);
      _impl_.mesh_warp_->Clear();
    }
  }
  _impl_.sample_timestamp_us_ = 0;
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* EISData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> EISData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EISData, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_EISData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double sample_timestamp_us = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 2, 0, PROTOBUF_FIELD_OFFSET(EISData, _impl_.sample_timestamp_us_)}},
    // .gyroflow.EISData.EISDataType type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EISData, _impl_.type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(EISData, _impl_.type_)}},
    // optional .gyroflow.Quaternion quaternion = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(EISData, _impl_.quaternion_)}},
    // optional .gyroflow.MeshWarpData mesh_warp = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(EISData, _impl_.mesh_warp_)}},
    // repeated float matrix_4x4 = 5;
    {::_pbi::TcParser::FastF32P1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(EISData, _impl_.matrix_4x4_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double sample_timestamp_us = 1;
    {PROTOBUF_FIELD_OFFSET(EISData, _impl_.sample_timestamp_us_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // .gyroflow.EISData.EISDataType type = 2;
    {PROTOBUF_FIELD_OFFSET(EISData, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // optional .gyroflow.Quaternion quaternion = 3;
    {PROTOBUF_FIELD_OFFSET(EISData, _impl_.quaternion_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .gyroflow.MeshWarpData mesh_warp = 4;
    {PROTOBUF_FIELD_OFFSET(EISData, _impl_.mesh_warp_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated float matrix_4x4 = 5;
    {PROTOBUF_FIELD_OFFSET(EISData, _impl_.matrix_4x4_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::gyroflow::Quaternion>()},
    {::_pbi::TcParser::GetTable<::gyroflow::MeshWarpData>()},
  }}, {{
  }},
};

::uint8_t* EISData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.EISData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double sample_timestamp_us = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_sample_timestamp_us(), target);
  }

  // .gyroflow.EISData.EISDataType type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  // optional .gyroflow.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::quaternion(this),
        _Internal::quaternion(this).GetCachedSize(), target, stream);
  }

  // optional .gyroflow.MeshWarpData mesh_warp = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::mesh_warp(this),
        _Internal::mesh_warp(this).GetCachedSize(), target, stream);
  }

  // repeated float matrix_4x4 = 5;
  if (this->_internal_matrix_4x4_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_matrix_4x4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.EISData)
  return target;
}

::size_t EISData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.EISData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float matrix_4x4 = 5;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_matrix_4x4_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .gyroflow.Quaternion quaternion = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.quaternion_);
    }

    // optional .gyroflow.MeshWarpData mesh_warp = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.mesh_warp_);
    }

    // optional double sample_timestamp_us = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  // .gyroflow.EISData.EISDataType type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData EISData::_class_data_ = {
    EISData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* EISData::GetClassData() const {
  return &_class_data_;
}

void EISData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<EISData*>(&to_msg);
  auto& from = static_cast<const EISData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.EISData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_matrix_4x4()->MergeFrom(from._internal_matrix_4x4());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_quaternion()->::gyroflow::Quaternion::MergeFrom(
          from._internal_quaternion());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_mesh_warp()->::gyroflow::MeshWarpData::MergeFrom(
          from._internal_mesh_warp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sample_timestamp_us_ = from._impl_.sample_timestamp_us_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EISData::CopyFrom(const EISData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.EISData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EISData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* EISData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void EISData::InternalSwap(EISData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.matrix_4x4_.InternalSwap(&other->_impl_.matrix_4x4_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EISData, _impl_.type_)
      + sizeof(EISData::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(EISData, _impl_.quaternion_)>(
          reinterpret_cast<char*>(&_impl_.quaternion_),
          reinterpret_cast<char*>(&other->_impl_.quaternion_));
}

::google::protobuf::Metadata EISData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[11]);
}
// ===================================================================

class MeshWarpData::_Internal {
 public:
};

MeshWarpData::MeshWarpData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:gyroflow.MeshWarpData)
}
inline PROTOBUF_NDEBUG_INLINE MeshWarpData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : values_{visibility, arena, from.values_},
        _cached_size_{0} {}

MeshWarpData::MeshWarpData(
    ::google::protobuf::Arena* arena,
    const MeshWarpData& from)
    : ::google::protobuf::Message(arena) {
  MeshWarpData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, grid_width_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, grid_width_),
           offsetof(Impl_, grid_height_) -
               offsetof(Impl_, grid_width_) +
               sizeof(Impl_::grid_height_));

  // @@protoc_insertion_point(copy_constructor:gyroflow.MeshWarpData)
}
inline PROTOBUF_NDEBUG_INLINE MeshWarpData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : values_{visibility, arena},
        _cached_size_{0} {}

inline void MeshWarpData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, grid_width_),
           0,
           offsetof(Impl_, grid_height_) -
               offsetof(Impl_, grid_width_) +
               sizeof(Impl_::grid_height_));
}
MeshWarpData::~MeshWarpData() {
  // @@protoc_insertion_point(destructor:gyroflow.MeshWarpData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MeshWarpData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MeshWarpData::Clear() {
// @@protoc_insertion_point(message_clear_start:gyroflow.MeshWarpData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  ::memset(&_impl_.grid_width_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.grid_height_) -
      reinterpret_cast<char*>(&_impl_.grid_width_)) + sizeof(_impl_.grid_height_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MeshWarpData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> MeshWarpData::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_MeshWarpData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 grid_width = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshWarpData, _impl_.grid_width_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_width_)}},
    // int32 grid_height = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshWarpData, _impl_.grid_height_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_height_)}},
    // repeated float values = 3;
    {::_pbi::TcParser::FastF32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.values_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 grid_width = 1;
    {PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_width_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 grid_height = 2;
    {PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_height_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // repeated float values = 3;
    {PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.values_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* MeshWarpData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gyroflow.MeshWarpData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 grid_width = 1;
  if (this->_internal_grid_width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_grid_width(), target);
  }

  // int32 grid_height = 2;
  if (this->_internal_grid_height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_grid_height(), target);
  }

  // repeated float values = 3;
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gyroflow.MeshWarpData)
  return target;
}

::size_t MeshWarpData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gyroflow.MeshWarpData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values = 3;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_values_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // int32 grid_width = 1;
  if (this->_internal_grid_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_grid_width());
  }

  // int32 grid_height = 2;
  if (this->_internal_grid_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_grid_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MeshWarpData::_class_data_ = {
    MeshWarpData::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* MeshWarpData::GetClassData() const {
  return &_class_data_;
}

void MeshWarpData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MeshWarpData*>(&to_msg);
  auto& from = static_cast<const MeshWarpData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gyroflow.MeshWarpData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_values()->MergeFrom(from._internal_values());
  if (from._internal_grid_width() != 0) {
    _this->_internal_set_grid_width(from._internal_grid_width());
  }
  if (from._internal_grid_height() != 0) {
    _this->_internal_set_grid_height(from._internal_grid_height());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MeshWarpData::CopyFrom(const MeshWarpData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gyroflow.MeshWarpData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MeshWarpData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* MeshWarpData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MeshWarpData::InternalSwap(MeshWarpData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_height_)
      + sizeof(MeshWarpData::_impl_.grid_height_)
      - PROTOBUF_FIELD_OFFSET(MeshWarpData, _impl_.grid_width_)>(
          reinterpret_cast<char*>(&_impl_.grid_width_),
          reinterpret_cast<char*>(&other->_impl_.grid_width_));
}

::google::protobuf::Metadata MeshWarpData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_proto_2fgyroflow_2eproto_getter, &descriptor_table_proto_2fgyroflow_2eproto_once,
      file_level_metadata_proto_2fgyroflow_2eproto[12]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace gyroflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
