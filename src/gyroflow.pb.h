// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/gyroflow.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fgyroflow_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fgyroflow_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fgyroflow_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fgyroflow_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2fgyroflow_2eproto;
namespace gyroflow {
class EISData;
struct EISDataDefaultTypeInternal;
extern EISDataDefaultTypeInternal _EISData_default_instance_;
class FrameMetadata;
struct FrameMetadataDefaultTypeInternal;
extern FrameMetadataDefaultTypeInternal _FrameMetadata_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Header_CameraMetadata;
struct Header_CameraMetadataDefaultTypeInternal;
extern Header_CameraMetadataDefaultTypeInternal _Header_CameraMetadata_default_instance_;
class Header_ClipMetadata;
struct Header_ClipMetadataDefaultTypeInternal;
extern Header_ClipMetadataDefaultTypeInternal _Header_ClipMetadata_default_instance_;
class IBISData;
struct IBISDataDefaultTypeInternal;
extern IBISDataDefaultTypeInternal _IBISData_default_instance_;
class IMUData;
struct IMUDataDefaultTypeInternal;
extern IMUDataDefaultTypeInternal _IMUData_default_instance_;
class LensData;
struct LensDataDefaultTypeInternal;
extern LensDataDefaultTypeInternal _LensData_default_instance_;
class LensOISData;
struct LensOISDataDefaultTypeInternal;
extern LensOISDataDefaultTypeInternal _LensOISData_default_instance_;
class Main;
struct MainDefaultTypeInternal;
extern MainDefaultTypeInternal _Main_default_instance_;
class MeshWarpData;
struct MeshWarpDataDefaultTypeInternal;
extern MeshWarpDataDefaultTypeInternal _MeshWarpData_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class QuaternionData;
struct QuaternionDataDefaultTypeInternal;
extern QuaternionDataDefaultTypeInternal _QuaternionData_default_instance_;
}  // namespace gyroflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace gyroflow {
enum Header_ClipMetadata_ReadoutDirection : int {
  Header_ClipMetadata_ReadoutDirection_TopToBottom = 0,
  Header_ClipMetadata_ReadoutDirection_BottomToTop = 1,
  Header_ClipMetadata_ReadoutDirection_RightToLeft = 2,
  Header_ClipMetadata_ReadoutDirection_LeftToRight = 3,
  Header_ClipMetadata_ReadoutDirection_Header_ClipMetadata_ReadoutDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Header_ClipMetadata_ReadoutDirection_Header_ClipMetadata_ReadoutDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Header_ClipMetadata_ReadoutDirection_IsValid(int value);
extern const uint32_t Header_ClipMetadata_ReadoutDirection_internal_data_[];
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata_ReadoutDirection_ReadoutDirection_MIN = static_cast<Header_ClipMetadata_ReadoutDirection>(0);
constexpr Header_ClipMetadata_ReadoutDirection Header_ClipMetadata_ReadoutDirection_ReadoutDirection_MAX = static_cast<Header_ClipMetadata_ReadoutDirection>(3);
constexpr int Header_ClipMetadata_ReadoutDirection_ReadoutDirection_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Header_ClipMetadata_ReadoutDirection_descriptor();
template <typename T>
const std::string& Header_ClipMetadata_ReadoutDirection_Name(T value) {
  static_assert(std::is_same<T, Header_ClipMetadata_ReadoutDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReadoutDirection_Name().");
  return Header_ClipMetadata_ReadoutDirection_Name(static_cast<Header_ClipMetadata_ReadoutDirection>(value));
}
template <>
inline const std::string& Header_ClipMetadata_ReadoutDirection_Name(Header_ClipMetadata_ReadoutDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Header_ClipMetadata_ReadoutDirection_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Header_ClipMetadata_ReadoutDirection_Parse(absl::string_view name, Header_ClipMetadata_ReadoutDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ClipMetadata_ReadoutDirection>(
      Header_ClipMetadata_ReadoutDirection_descriptor(), name, value);
}
enum LensData_DistortionModel : int {
  LensData_DistortionModel_OpenCVFisheye = 0,
  LensData_DistortionModel_OpenCVStandard = 1,
  LensData_DistortionModel_Poly3 = 2,
  LensData_DistortionModel_Poly5 = 3,
  LensData_DistortionModel_PTLens = 4,
  LensData_DistortionModel_GenericPolynomial = 5,
  LensData_DistortionModel_LensData_DistortionModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LensData_DistortionModel_LensData_DistortionModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LensData_DistortionModel_IsValid(int value);
extern const uint32_t LensData_DistortionModel_internal_data_[];
constexpr LensData_DistortionModel LensData_DistortionModel_DistortionModel_MIN = static_cast<LensData_DistortionModel>(0);
constexpr LensData_DistortionModel LensData_DistortionModel_DistortionModel_MAX = static_cast<LensData_DistortionModel>(5);
constexpr int LensData_DistortionModel_DistortionModel_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
LensData_DistortionModel_descriptor();
template <typename T>
const std::string& LensData_DistortionModel_Name(T value) {
  static_assert(std::is_same<T, LensData_DistortionModel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DistortionModel_Name().");
  return LensData_DistortionModel_Name(static_cast<LensData_DistortionModel>(value));
}
template <>
inline const std::string& LensData_DistortionModel_Name(LensData_DistortionModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LensData_DistortionModel_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool LensData_DistortionModel_Parse(absl::string_view name, LensData_DistortionModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LensData_DistortionModel>(
      LensData_DistortionModel_descriptor(), name, value);
}
enum EISData_EISDataType : int {
  EISData_EISDataType_QUATERNION = 0,
  EISData_EISDataType_MESH_WARP = 1,
  EISData_EISDataType_MATRIX_4X4 = 2,
  EISData_EISDataType_EISData_EISDataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EISData_EISDataType_EISData_EISDataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EISData_EISDataType_IsValid(int value);
extern const uint32_t EISData_EISDataType_internal_data_[];
constexpr EISData_EISDataType EISData_EISDataType_EISDataType_MIN = static_cast<EISData_EISDataType>(0);
constexpr EISData_EISDataType EISData_EISDataType_EISDataType_MAX = static_cast<EISData_EISDataType>(2);
constexpr int EISData_EISDataType_EISDataType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
EISData_EISDataType_descriptor();
template <typename T>
const std::string& EISData_EISDataType_Name(T value) {
  static_assert(std::is_same<T, EISData_EISDataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EISDataType_Name().");
  return EISData_EISDataType_Name(static_cast<EISData_EISDataType>(value));
}
template <>
inline const std::string& EISData_EISDataType_Name(EISData_EISDataType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EISData_EISDataType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool EISData_EISDataType_Parse(absl::string_view name, EISData_EISDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EISData_EISDataType>(
      EISData_EISDataType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline Quaternion(const Quaternion& from)
      : Quaternion(nullptr, from) {}
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.Quaternion";
  }
  protected:
  explicit Quaternion(::google::protobuf::Arena* arena);
  Quaternion(::google::protobuf::Arena* arena, const Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // float w = 1;
  void clear_w() ;
  float w() const;
  void set_w(float value);

  private:
  float _internal_w() const;
  void _internal_set_w(float value);

  public:
  // float x = 2;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 3;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 4;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float w_;
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class MeshWarpData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.MeshWarpData) */ {
 public:
  inline MeshWarpData() : MeshWarpData(nullptr) {}
  ~MeshWarpData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MeshWarpData(::google::protobuf::internal::ConstantInitialized);

  inline MeshWarpData(const MeshWarpData& from)
      : MeshWarpData(nullptr, from) {}
  MeshWarpData(MeshWarpData&& from) noexcept
    : MeshWarpData() {
    *this = ::std::move(from);
  }

  inline MeshWarpData& operator=(const MeshWarpData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshWarpData& operator=(MeshWarpData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshWarpData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshWarpData* internal_default_instance() {
    return reinterpret_cast<const MeshWarpData*>(
               &_MeshWarpData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MeshWarpData& a, MeshWarpData& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshWarpData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshWarpData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshWarpData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshWarpData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshWarpData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MeshWarpData& from) {
    MeshWarpData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MeshWarpData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.MeshWarpData";
  }
  protected:
  explicit MeshWarpData(::google::protobuf::Arena* arena);
  MeshWarpData(::google::protobuf::Arena* arena, const MeshWarpData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kGridWidthFieldNumber = 1,
    kGridHeightFieldNumber = 2,
  };
  // repeated float values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField<float>& values() const;
  ::google::protobuf::RepeatedField<float>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_values() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_values();

  public:
  // int32 grid_width = 1;
  void clear_grid_width() ;
  ::int32_t grid_width() const;
  void set_grid_width(::int32_t value);

  private:
  ::int32_t _internal_grid_width() const;
  void _internal_set_grid_width(::int32_t value);

  public:
  // int32 grid_height = 2;
  void clear_grid_height() ;
  ::int32_t grid_height() const;
  void set_grid_height(::int32_t value);

  private:
  ::int32_t _internal_grid_height() const;
  void _internal_set_grid_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.MeshWarpData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> values_;
    ::int32_t grid_width_;
    ::int32_t grid_height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class LensOISData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.LensOISData) */ {
 public:
  inline LensOISData() : LensOISData(nullptr) {}
  ~LensOISData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LensOISData(::google::protobuf::internal::ConstantInitialized);

  inline LensOISData(const LensOISData& from)
      : LensOISData(nullptr, from) {}
  LensOISData(LensOISData&& from) noexcept
    : LensOISData() {
    *this = ::std::move(from);
  }

  inline LensOISData& operator=(const LensOISData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LensOISData& operator=(LensOISData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LensOISData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LensOISData* internal_default_instance() {
    return reinterpret_cast<const LensOISData*>(
               &_LensOISData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LensOISData& a, LensOISData& b) {
    a.Swap(&b);
  }
  inline void Swap(LensOISData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LensOISData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LensOISData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LensOISData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LensOISData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LensOISData& from) {
    LensOISData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LensOISData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.LensOISData";
  }
  protected:
  explicit LensOISData(::google::protobuf::Arena* arena);
  LensOISData(::google::protobuf::Arena* arena, const LensOISData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleTimestampUsFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // double sample_timestamp_us = 1;
  void clear_sample_timestamp_us() ;
  double sample_timestamp_us() const;
  void set_sample_timestamp_us(double value);

  private:
  double _internal_sample_timestamp_us() const;
  void _internal_set_sample_timestamp_us(double value);

  public:
  // float x = 2;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 3;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.LensOISData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double sample_timestamp_us_;
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class LensData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.LensData) */ {
 public:
  inline LensData() : LensData(nullptr) {}
  ~LensData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LensData(::google::protobuf::internal::ConstantInitialized);

  inline LensData(const LensData& from)
      : LensData(nullptr, from) {}
  LensData(LensData&& from) noexcept
    : LensData() {
    *this = ::std::move(from);
  }

  inline LensData& operator=(const LensData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LensData& operator=(LensData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LensData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LensData* internal_default_instance() {
    return reinterpret_cast<const LensData*>(
               &_LensData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LensData& a, LensData& b) {
    a.Swap(&b);
  }
  inline void Swap(LensData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LensData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LensData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LensData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LensData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LensData& from) {
    LensData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LensData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.LensData";
  }
  protected:
  explicit LensData(::google::protobuf::Arena* arena);
  LensData(::google::protobuf::Arena* arena, const LensData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DistortionModel = LensData_DistortionModel;
  static constexpr DistortionModel OpenCVFisheye = LensData_DistortionModel_OpenCVFisheye;
  static constexpr DistortionModel OpenCVStandard = LensData_DistortionModel_OpenCVStandard;
  static constexpr DistortionModel Poly3 = LensData_DistortionModel_Poly3;
  static constexpr DistortionModel Poly5 = LensData_DistortionModel_Poly5;
  static constexpr DistortionModel PTLens = LensData_DistortionModel_PTLens;
  static constexpr DistortionModel GenericPolynomial = LensData_DistortionModel_GenericPolynomial;
  static inline bool DistortionModel_IsValid(int value) {
    return LensData_DistortionModel_IsValid(value);
  }
  static constexpr DistortionModel DistortionModel_MIN = LensData_DistortionModel_DistortionModel_MIN;
  static constexpr DistortionModel DistortionModel_MAX = LensData_DistortionModel_DistortionModel_MAX;
  static constexpr int DistortionModel_ARRAYSIZE = LensData_DistortionModel_DistortionModel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DistortionModel_descriptor() {
    return LensData_DistortionModel_descriptor();
  }
  template <typename T>
  static inline const std::string& DistortionModel_Name(T value) {
    return LensData_DistortionModel_Name(value);
  }
  static inline bool DistortionModel_Parse(absl::string_view name, DistortionModel* value) {
    return LensData_DistortionModel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDistortionCoefficientsFieldNumber = 2,
    kCameraIntrinsicMatrixFieldNumber = 3,
    kDistortionModelFieldNumber = 1,
    kFocalLengthMmFieldNumber = 4,
    kFNumberFieldNumber = 5,
    kFocusDistanceMmFieldNumber = 6,
  };
  // repeated float distortion_coefficients = 2;
  int distortion_coefficients_size() const;
  private:
  int _internal_distortion_coefficients_size() const;

  public:
  void clear_distortion_coefficients() ;
  float distortion_coefficients(int index) const;
  void set_distortion_coefficients(int index, float value);
  void add_distortion_coefficients(float value);
  const ::google::protobuf::RepeatedField<float>& distortion_coefficients() const;
  ::google::protobuf::RepeatedField<float>* mutable_distortion_coefficients();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_distortion_coefficients() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_distortion_coefficients();

  public:
  // repeated float camera_intrinsic_matrix = 3;
  int camera_intrinsic_matrix_size() const;
  private:
  int _internal_camera_intrinsic_matrix_size() const;

  public:
  void clear_camera_intrinsic_matrix() ;
  float camera_intrinsic_matrix(int index) const;
  void set_camera_intrinsic_matrix(int index, float value);
  void add_camera_intrinsic_matrix(float value);
  const ::google::protobuf::RepeatedField<float>& camera_intrinsic_matrix() const;
  ::google::protobuf::RepeatedField<float>* mutable_camera_intrinsic_matrix();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_camera_intrinsic_matrix() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_camera_intrinsic_matrix();

  public:
  // .gyroflow.LensData.DistortionModel distortion_model = 1;
  void clear_distortion_model() ;
  ::gyroflow::LensData_DistortionModel distortion_model() const;
  void set_distortion_model(::gyroflow::LensData_DistortionModel value);

  private:
  ::gyroflow::LensData_DistortionModel _internal_distortion_model() const;
  void _internal_set_distortion_model(::gyroflow::LensData_DistortionModel value);

  public:
  // optional float focal_length_mm = 4;
  bool has_focal_length_mm() const;
  void clear_focal_length_mm() ;
  float focal_length_mm() const;
  void set_focal_length_mm(float value);

  private:
  float _internal_focal_length_mm() const;
  void _internal_set_focal_length_mm(float value);

  public:
  // optional float f_number = 5;
  bool has_f_number() const;
  void clear_f_number() ;
  float f_number() const;
  void set_f_number(float value);

  private:
  float _internal_f_number() const;
  void _internal_set_f_number(float value);

  public:
  // optional float focus_distance_mm = 6;
  bool has_focus_distance_mm() const;
  void clear_focus_distance_mm() ;
  float focus_distance_mm() const;
  void set_focus_distance_mm(float value);

  private:
  float _internal_focus_distance_mm() const;
  void _internal_set_focus_distance_mm(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.LensData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> distortion_coefficients_;
    ::google::protobuf::RepeatedField<float> camera_intrinsic_matrix_;
    int distortion_model_;
    float focal_length_mm_;
    float f_number_;
    float focus_distance_mm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class IMUData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.IMUData) */ {
 public:
  inline IMUData() : IMUData(nullptr) {}
  ~IMUData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IMUData(::google::protobuf::internal::ConstantInitialized);

  inline IMUData(const IMUData& from)
      : IMUData(nullptr, from) {}
  IMUData(IMUData&& from) noexcept
    : IMUData() {
    *this = ::std::move(from);
  }

  inline IMUData& operator=(const IMUData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUData& operator=(IMUData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUData* internal_default_instance() {
    return reinterpret_cast<const IMUData*>(
               &_IMUData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IMUData& a, IMUData& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMUData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMUData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IMUData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IMUData& from) {
    IMUData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IMUData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.IMUData";
  }
  protected:
  explicit IMUData(::google::protobuf::Arena* arena);
  IMUData(::google::protobuf::Arena* arena, const IMUData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleTimestampUsFieldNumber = 1,
    kGyroscopeXFieldNumber = 2,
    kGyroscopeYFieldNumber = 3,
    kGyroscopeZFieldNumber = 4,
    kAccelerometerXFieldNumber = 5,
    kAccelerometerYFieldNumber = 6,
    kAccelerometerZFieldNumber = 7,
    kMagnetometerXFieldNumber = 8,
    kMagnetometerYFieldNumber = 9,
    kMagnetometerZFieldNumber = 10,
  };
  // double sample_timestamp_us = 1;
  void clear_sample_timestamp_us() ;
  double sample_timestamp_us() const;
  void set_sample_timestamp_us(double value);

  private:
  double _internal_sample_timestamp_us() const;
  void _internal_set_sample_timestamp_us(double value);

  public:
  // float gyroscope_x = 2;
  void clear_gyroscope_x() ;
  float gyroscope_x() const;
  void set_gyroscope_x(float value);

  private:
  float _internal_gyroscope_x() const;
  void _internal_set_gyroscope_x(float value);

  public:
  // float gyroscope_y = 3;
  void clear_gyroscope_y() ;
  float gyroscope_y() const;
  void set_gyroscope_y(float value);

  private:
  float _internal_gyroscope_y() const;
  void _internal_set_gyroscope_y(float value);

  public:
  // float gyroscope_z = 4;
  void clear_gyroscope_z() ;
  float gyroscope_z() const;
  void set_gyroscope_z(float value);

  private:
  float _internal_gyroscope_z() const;
  void _internal_set_gyroscope_z(float value);

  public:
  // float accelerometer_x = 5;
  void clear_accelerometer_x() ;
  float accelerometer_x() const;
  void set_accelerometer_x(float value);

  private:
  float _internal_accelerometer_x() const;
  void _internal_set_accelerometer_x(float value);

  public:
  // float accelerometer_y = 6;
  void clear_accelerometer_y() ;
  float accelerometer_y() const;
  void set_accelerometer_y(float value);

  private:
  float _internal_accelerometer_y() const;
  void _internal_set_accelerometer_y(float value);

  public:
  // float accelerometer_z = 7;
  void clear_accelerometer_z() ;
  float accelerometer_z() const;
  void set_accelerometer_z(float value);

  private:
  float _internal_accelerometer_z() const;
  void _internal_set_accelerometer_z(float value);

  public:
  // optional float magnetometer_x = 8;
  bool has_magnetometer_x() const;
  void clear_magnetometer_x() ;
  float magnetometer_x() const;
  void set_magnetometer_x(float value);

  private:
  float _internal_magnetometer_x() const;
  void _internal_set_magnetometer_x(float value);

  public:
  // optional float magnetometer_y = 9;
  bool has_magnetometer_y() const;
  void clear_magnetometer_y() ;
  float magnetometer_y() const;
  void set_magnetometer_y(float value);

  private:
  float _internal_magnetometer_y() const;
  void _internal_set_magnetometer_y(float value);

  public:
  // optional float magnetometer_z = 10;
  bool has_magnetometer_z() const;
  void clear_magnetometer_z() ;
  float magnetometer_z() const;
  void set_magnetometer_z(float value);

  private:
  float _internal_magnetometer_z() const;
  void _internal_set_magnetometer_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.IMUData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double sample_timestamp_us_;
    float gyroscope_x_;
    float gyroscope_y_;
    float gyroscope_z_;
    float accelerometer_x_;
    float accelerometer_y_;
    float accelerometer_z_;
    float magnetometer_x_;
    float magnetometer_y_;
    float magnetometer_z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class IBISData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.IBISData) */ {
 public:
  inline IBISData() : IBISData(nullptr) {}
  ~IBISData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IBISData(::google::protobuf::internal::ConstantInitialized);

  inline IBISData(const IBISData& from)
      : IBISData(nullptr, from) {}
  IBISData(IBISData&& from) noexcept
    : IBISData() {
    *this = ::std::move(from);
  }

  inline IBISData& operator=(const IBISData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IBISData& operator=(IBISData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IBISData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IBISData* internal_default_instance() {
    return reinterpret_cast<const IBISData*>(
               &_IBISData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IBISData& a, IBISData& b) {
    a.Swap(&b);
  }
  inline void Swap(IBISData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IBISData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IBISData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IBISData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IBISData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IBISData& from) {
    IBISData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IBISData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.IBISData";
  }
  protected:
  explicit IBISData(::google::protobuf::Arena* arena);
  IBISData(::google::protobuf::Arena* arena, const IBISData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleTimestampUsFieldNumber = 1,
    kShiftXFieldNumber = 2,
    kShiftYFieldNumber = 3,
    kRollAngleDegreesFieldNumber = 4,
  };
  // double sample_timestamp_us = 1;
  void clear_sample_timestamp_us() ;
  double sample_timestamp_us() const;
  void set_sample_timestamp_us(double value);

  private:
  double _internal_sample_timestamp_us() const;
  void _internal_set_sample_timestamp_us(double value);

  public:
  // float shift_x = 2;
  void clear_shift_x() ;
  float shift_x() const;
  void set_shift_x(float value);

  private:
  float _internal_shift_x() const;
  void _internal_set_shift_x(float value);

  public:
  // float shift_y = 3;
  void clear_shift_y() ;
  float shift_y() const;
  void set_shift_y(float value);

  private:
  float _internal_shift_y() const;
  void _internal_set_shift_y(float value);

  public:
  // float roll_angle_degrees = 4;
  void clear_roll_angle_degrees() ;
  float roll_angle_degrees() const;
  void set_roll_angle_degrees(float value);

  private:
  float _internal_roll_angle_degrees() const;
  void _internal_set_roll_angle_degrees(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.IBISData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double sample_timestamp_us_;
    float shift_x_;
    float shift_y_;
    float roll_angle_degrees_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class Header_ClipMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.Header.ClipMetadata) */ {
 public:
  inline Header_ClipMetadata() : Header_ClipMetadata(nullptr) {}
  ~Header_ClipMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header_ClipMetadata(::google::protobuf::internal::ConstantInitialized);

  inline Header_ClipMetadata(const Header_ClipMetadata& from)
      : Header_ClipMetadata(nullptr, from) {}
  Header_ClipMetadata(Header_ClipMetadata&& from) noexcept
    : Header_ClipMetadata() {
    *this = ::std::move(from);
  }

  inline Header_ClipMetadata& operator=(const Header_ClipMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header_ClipMetadata& operator=(Header_ClipMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header_ClipMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header_ClipMetadata* internal_default_instance() {
    return reinterpret_cast<const Header_ClipMetadata*>(
               &_Header_ClipMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Header_ClipMetadata& a, Header_ClipMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Header_ClipMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header_ClipMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header_ClipMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header_ClipMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header_ClipMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header_ClipMetadata& from) {
    Header_ClipMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header_ClipMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.Header.ClipMetadata";
  }
  protected:
  explicit Header_ClipMetadata(::google::protobuf::Arena* arena);
  Header_ClipMetadata(::google::protobuf::Arena* arena, const Header_ClipMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ReadoutDirection = Header_ClipMetadata_ReadoutDirection;
  static constexpr ReadoutDirection TopToBottom = Header_ClipMetadata_ReadoutDirection_TopToBottom;
  static constexpr ReadoutDirection BottomToTop = Header_ClipMetadata_ReadoutDirection_BottomToTop;
  static constexpr ReadoutDirection RightToLeft = Header_ClipMetadata_ReadoutDirection_RightToLeft;
  static constexpr ReadoutDirection LeftToRight = Header_ClipMetadata_ReadoutDirection_LeftToRight;
  static inline bool ReadoutDirection_IsValid(int value) {
    return Header_ClipMetadata_ReadoutDirection_IsValid(value);
  }
  static constexpr ReadoutDirection ReadoutDirection_MIN = Header_ClipMetadata_ReadoutDirection_ReadoutDirection_MIN;
  static constexpr ReadoutDirection ReadoutDirection_MAX = Header_ClipMetadata_ReadoutDirection_ReadoutDirection_MAX;
  static constexpr int ReadoutDirection_ARRAYSIZE = Header_ClipMetadata_ReadoutDirection_ReadoutDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReadoutDirection_descriptor() {
    return Header_ClipMetadata_ReadoutDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& ReadoutDirection_Name(T value) {
    return Header_ClipMetadata_ReadoutDirection_Name(value);
  }
  static inline bool ReadoutDirection_Parse(absl::string_view name, ReadoutDirection* value) {
    return Header_ClipMetadata_ReadoutDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorProfileFieldNumber = 9,
    kFrameWidthFieldNumber = 1,
    kFrameHeightFieldNumber = 2,
    kDurationUsFieldNumber = 3,
    kRecordFrameRateFieldNumber = 4,
    kSensorFrameRateFieldNumber = 5,
    kFileFrameRateFieldNumber = 6,
    kRotationDegreesFieldNumber = 7,
    kImuSampleRateFieldNumber = 8,
    kPixelAspectRatioFieldNumber = 10,
    kFrameReadoutTimeUsFieldNumber = 11,
    kFrameReadoutDirectionFieldNumber = 12,
  };
  // optional string color_profile = 9;
  bool has_color_profile() const;
  void clear_color_profile() ;
  const std::string& color_profile() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color_profile(Arg_&& arg, Args_... args);
  std::string* mutable_color_profile();
  PROTOBUF_NODISCARD std::string* release_color_profile();
  void set_allocated_color_profile(std::string* value);

  private:
  const std::string& _internal_color_profile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color_profile(
      const std::string& value);
  std::string* _internal_mutable_color_profile();

  public:
  // uint32 frame_width = 1;
  void clear_frame_width() ;
  ::uint32_t frame_width() const;
  void set_frame_width(::uint32_t value);

  private:
  ::uint32_t _internal_frame_width() const;
  void _internal_set_frame_width(::uint32_t value);

  public:
  // uint32 frame_height = 2;
  void clear_frame_height() ;
  ::uint32_t frame_height() const;
  void set_frame_height(::uint32_t value);

  private:
  ::uint32_t _internal_frame_height() const;
  void _internal_set_frame_height(::uint32_t value);

  public:
  // float duration_us = 3;
  void clear_duration_us() ;
  float duration_us() const;
  void set_duration_us(float value);

  private:
  float _internal_duration_us() const;
  void _internal_set_duration_us(float value);

  public:
  // float record_frame_rate = 4;
  void clear_record_frame_rate() ;
  float record_frame_rate() const;
  void set_record_frame_rate(float value);

  private:
  float _internal_record_frame_rate() const;
  void _internal_set_record_frame_rate(float value);

  public:
  // float sensor_frame_rate = 5;
  void clear_sensor_frame_rate() ;
  float sensor_frame_rate() const;
  void set_sensor_frame_rate(float value);

  private:
  float _internal_sensor_frame_rate() const;
  void _internal_set_sensor_frame_rate(float value);

  public:
  // float file_frame_rate = 6;
  void clear_file_frame_rate() ;
  float file_frame_rate() const;
  void set_file_frame_rate(float value);

  private:
  float _internal_file_frame_rate() const;
  void _internal_set_file_frame_rate(float value);

  public:
  // int32 rotation_degrees = 7;
  void clear_rotation_degrees() ;
  ::int32_t rotation_degrees() const;
  void set_rotation_degrees(::int32_t value);

  private:
  ::int32_t _internal_rotation_degrees() const;
  void _internal_set_rotation_degrees(::int32_t value);

  public:
  // uint32 imu_sample_rate = 8;
  void clear_imu_sample_rate() ;
  ::uint32_t imu_sample_rate() const;
  void set_imu_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_imu_sample_rate() const;
  void _internal_set_imu_sample_rate(::uint32_t value);

  public:
  // float pixel_aspect_ratio = 10;
  void clear_pixel_aspect_ratio() ;
  float pixel_aspect_ratio() const;
  void set_pixel_aspect_ratio(float value);

  private:
  float _internal_pixel_aspect_ratio() const;
  void _internal_set_pixel_aspect_ratio(float value);

  public:
  // float frame_readout_time_us = 11;
  void clear_frame_readout_time_us() ;
  float frame_readout_time_us() const;
  void set_frame_readout_time_us(float value);

  private:
  float _internal_frame_readout_time_us() const;
  void _internal_set_frame_readout_time_us(float value);

  public:
  // .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
  void clear_frame_readout_direction() ;
  ::gyroflow::Header_ClipMetadata_ReadoutDirection frame_readout_direction() const;
  void set_frame_readout_direction(::gyroflow::Header_ClipMetadata_ReadoutDirection value);

  private:
  ::gyroflow::Header_ClipMetadata_ReadoutDirection _internal_frame_readout_direction() const;
  void _internal_set_frame_readout_direction(::gyroflow::Header_ClipMetadata_ReadoutDirection value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.Header.ClipMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_profile_;
    ::uint32_t frame_width_;
    ::uint32_t frame_height_;
    float duration_us_;
    float record_frame_rate_;
    float sensor_frame_rate_;
    float file_frame_rate_;
    ::int32_t rotation_degrees_;
    ::uint32_t imu_sample_rate_;
    float pixel_aspect_ratio_;
    float frame_readout_time_us_;
    int frame_readout_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class QuaternionData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.QuaternionData) */ {
 public:
  inline QuaternionData() : QuaternionData(nullptr) {}
  ~QuaternionData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuaternionData(::google::protobuf::internal::ConstantInitialized);

  inline QuaternionData(const QuaternionData& from)
      : QuaternionData(nullptr, from) {}
  QuaternionData(QuaternionData&& from) noexcept
    : QuaternionData() {
    *this = ::std::move(from);
  }

  inline QuaternionData& operator=(const QuaternionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuaternionData& operator=(QuaternionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuaternionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuaternionData* internal_default_instance() {
    return reinterpret_cast<const QuaternionData*>(
               &_QuaternionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(QuaternionData& a, QuaternionData& b) {
    a.Swap(&b);
  }
  inline void Swap(QuaternionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuaternionData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuaternionData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuaternionData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuaternionData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuaternionData& from) {
    QuaternionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuaternionData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.QuaternionData";
  }
  protected:
  explicit QuaternionData(::google::protobuf::Arena* arena);
  QuaternionData(::google::protobuf::Arena* arena, const QuaternionData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuatFieldNumber = 2,
    kSampleTimestampUsFieldNumber = 1,
  };
  // .gyroflow.Quaternion quat = 2;
  bool has_quat() const;
  void clear_quat() ;
  const ::gyroflow::Quaternion& quat() const;
  PROTOBUF_NODISCARD ::gyroflow::Quaternion* release_quat();
  ::gyroflow::Quaternion* mutable_quat();
  void set_allocated_quat(::gyroflow::Quaternion* value);
  void unsafe_arena_set_allocated_quat(::gyroflow::Quaternion* value);
  ::gyroflow::Quaternion* unsafe_arena_release_quat();

  private:
  const ::gyroflow::Quaternion& _internal_quat() const;
  ::gyroflow::Quaternion* _internal_mutable_quat();

  public:
  // double sample_timestamp_us = 1;
  void clear_sample_timestamp_us() ;
  double sample_timestamp_us() const;
  void set_sample_timestamp_us(double value);

  private:
  double _internal_sample_timestamp_us() const;
  void _internal_set_sample_timestamp_us(double value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.QuaternionData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::gyroflow::Quaternion* quat_;
    double sample_timestamp_us_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class Header_CameraMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.Header.CameraMetadata) */ {
 public:
  inline Header_CameraMetadata() : Header_CameraMetadata(nullptr) {}
  ~Header_CameraMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header_CameraMetadata(::google::protobuf::internal::ConstantInitialized);

  inline Header_CameraMetadata(const Header_CameraMetadata& from)
      : Header_CameraMetadata(nullptr, from) {}
  Header_CameraMetadata(Header_CameraMetadata&& from) noexcept
    : Header_CameraMetadata() {
    *this = ::std::move(from);
  }

  inline Header_CameraMetadata& operator=(const Header_CameraMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header_CameraMetadata& operator=(Header_CameraMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header_CameraMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header_CameraMetadata* internal_default_instance() {
    return reinterpret_cast<const Header_CameraMetadata*>(
               &_Header_CameraMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Header_CameraMetadata& a, Header_CameraMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Header_CameraMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header_CameraMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header_CameraMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header_CameraMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header_CameraMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header_CameraMetadata& from) {
    Header_CameraMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header_CameraMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.Header.CameraMetadata";
  }
  protected:
  explicit Header_CameraMetadata(::google::protobuf::Arena* arena);
  Header_CameraMetadata(::google::protobuf::Arena* arena, const Header_CameraMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraBrandFieldNumber = 1,
    kCameraModelFieldNumber = 2,
    kCameraSerialNumberFieldNumber = 3,
    kFirmwareVersionFieldNumber = 4,
    kLensBrandFieldNumber = 5,
    kLensModelFieldNumber = 6,
    kLensProfileFieldNumber = 11,
    kImuOrientationFieldNumber = 12,
    kAdditionalDataFieldNumber = 15,
    kImuRotationFieldNumber = 13,
    kQuatsRotationFieldNumber = 14,
    kPixelPitchNmFieldNumber = 7,
    kSensorPixelWidthFieldNumber = 8,
    kSensorPixelHeightFieldNumber = 9,
    kCropFactorFieldNumber = 10,
  };
  // string camera_brand = 1;
  void clear_camera_brand() ;
  const std::string& camera_brand() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_brand(Arg_&& arg, Args_... args);
  std::string* mutable_camera_brand();
  PROTOBUF_NODISCARD std::string* release_camera_brand();
  void set_allocated_camera_brand(std::string* value);

  private:
  const std::string& _internal_camera_brand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_brand(
      const std::string& value);
  std::string* _internal_mutable_camera_brand();

  public:
  // string camera_model = 2;
  void clear_camera_model() ;
  const std::string& camera_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_model(Arg_&& arg, Args_... args);
  std::string* mutable_camera_model();
  PROTOBUF_NODISCARD std::string* release_camera_model();
  void set_allocated_camera_model(std::string* value);

  private:
  const std::string& _internal_camera_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_model(
      const std::string& value);
  std::string* _internal_mutable_camera_model();

  public:
  // optional string camera_serial_number = 3;
  bool has_camera_serial_number() const;
  void clear_camera_serial_number() ;
  const std::string& camera_serial_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_camera_serial_number(Arg_&& arg, Args_... args);
  std::string* mutable_camera_serial_number();
  PROTOBUF_NODISCARD std::string* release_camera_serial_number();
  void set_allocated_camera_serial_number(std::string* value);

  private:
  const std::string& _internal_camera_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_serial_number(
      const std::string& value);
  std::string* _internal_mutable_camera_serial_number();

  public:
  // optional string firmware_version = 4;
  bool has_firmware_version() const;
  void clear_firmware_version() ;
  const std::string& firmware_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firmware_version(Arg_&& arg, Args_... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* value);

  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(
      const std::string& value);
  std::string* _internal_mutable_firmware_version();

  public:
  // string lens_brand = 5;
  void clear_lens_brand() ;
  const std::string& lens_brand() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lens_brand(Arg_&& arg, Args_... args);
  std::string* mutable_lens_brand();
  PROTOBUF_NODISCARD std::string* release_lens_brand();
  void set_allocated_lens_brand(std::string* value);

  private:
  const std::string& _internal_lens_brand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lens_brand(
      const std::string& value);
  std::string* _internal_mutable_lens_brand();

  public:
  // string lens_model = 6;
  void clear_lens_model() ;
  const std::string& lens_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lens_model(Arg_&& arg, Args_... args);
  std::string* mutable_lens_model();
  PROTOBUF_NODISCARD std::string* release_lens_model();
  void set_allocated_lens_model(std::string* value);

  private:
  const std::string& _internal_lens_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lens_model(
      const std::string& value);
  std::string* _internal_mutable_lens_model();

  public:
  // optional string lens_profile = 11;
  bool has_lens_profile() const;
  void clear_lens_profile() ;
  const std::string& lens_profile() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lens_profile(Arg_&& arg, Args_... args);
  std::string* mutable_lens_profile();
  PROTOBUF_NODISCARD std::string* release_lens_profile();
  void set_allocated_lens_profile(std::string* value);

  private:
  const std::string& _internal_lens_profile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lens_profile(
      const std::string& value);
  std::string* _internal_mutable_lens_profile();

  public:
  // optional string imu_orientation = 12;
  bool has_imu_orientation() const;
  void clear_imu_orientation() ;
  const std::string& imu_orientation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_imu_orientation(Arg_&& arg, Args_... args);
  std::string* mutable_imu_orientation();
  PROTOBUF_NODISCARD std::string* release_imu_orientation();
  void set_allocated_imu_orientation(std::string* value);

  private:
  const std::string& _internal_imu_orientation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imu_orientation(
      const std::string& value);
  std::string* _internal_mutable_imu_orientation();

  public:
  // optional string additional_data = 15;
  bool has_additional_data() const;
  void clear_additional_data() ;
  const std::string& additional_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_additional_data(Arg_&& arg, Args_... args);
  std::string* mutable_additional_data();
  PROTOBUF_NODISCARD std::string* release_additional_data();
  void set_allocated_additional_data(std::string* value);

  private:
  const std::string& _internal_additional_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_additional_data(
      const std::string& value);
  std::string* _internal_mutable_additional_data();

  public:
  // optional .gyroflow.Quaternion imu_rotation = 13;
  bool has_imu_rotation() const;
  void clear_imu_rotation() ;
  const ::gyroflow::Quaternion& imu_rotation() const;
  PROTOBUF_NODISCARD ::gyroflow::Quaternion* release_imu_rotation();
  ::gyroflow::Quaternion* mutable_imu_rotation();
  void set_allocated_imu_rotation(::gyroflow::Quaternion* value);
  void unsafe_arena_set_allocated_imu_rotation(::gyroflow::Quaternion* value);
  ::gyroflow::Quaternion* unsafe_arena_release_imu_rotation();

  private:
  const ::gyroflow::Quaternion& _internal_imu_rotation() const;
  ::gyroflow::Quaternion* _internal_mutable_imu_rotation();

  public:
  // optional .gyroflow.Quaternion quats_rotation = 14;
  bool has_quats_rotation() const;
  void clear_quats_rotation() ;
  const ::gyroflow::Quaternion& quats_rotation() const;
  PROTOBUF_NODISCARD ::gyroflow::Quaternion* release_quats_rotation();
  ::gyroflow::Quaternion* mutable_quats_rotation();
  void set_allocated_quats_rotation(::gyroflow::Quaternion* value);
  void unsafe_arena_set_allocated_quats_rotation(::gyroflow::Quaternion* value);
  ::gyroflow::Quaternion* unsafe_arena_release_quats_rotation();

  private:
  const ::gyroflow::Quaternion& _internal_quats_rotation() const;
  ::gyroflow::Quaternion* _internal_mutable_quats_rotation();

  public:
  // uint32 pixel_pitch_nm = 7;
  void clear_pixel_pitch_nm() ;
  ::uint32_t pixel_pitch_nm() const;
  void set_pixel_pitch_nm(::uint32_t value);

  private:
  ::uint32_t _internal_pixel_pitch_nm() const;
  void _internal_set_pixel_pitch_nm(::uint32_t value);

  public:
  // uint32 sensor_pixel_width = 8;
  void clear_sensor_pixel_width() ;
  ::uint32_t sensor_pixel_width() const;
  void set_sensor_pixel_width(::uint32_t value);

  private:
  ::uint32_t _internal_sensor_pixel_width() const;
  void _internal_set_sensor_pixel_width(::uint32_t value);

  public:
  // uint32 sensor_pixel_height = 9;
  void clear_sensor_pixel_height() ;
  ::uint32_t sensor_pixel_height() const;
  void set_sensor_pixel_height(::uint32_t value);

  private:
  ::uint32_t _internal_sensor_pixel_height() const;
  void _internal_set_sensor_pixel_height(::uint32_t value);

  public:
  // optional float crop_factor = 10;
  bool has_crop_factor() const;
  void clear_crop_factor() ;
  float crop_factor() const;
  void set_crop_factor(float value);

  private:
  float _internal_crop_factor() const;
  void _internal_set_crop_factor(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.Header.CameraMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 2,
      169, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr camera_brand_;
    ::google::protobuf::internal::ArenaStringPtr camera_model_;
    ::google::protobuf::internal::ArenaStringPtr camera_serial_number_;
    ::google::protobuf::internal::ArenaStringPtr firmware_version_;
    ::google::protobuf::internal::ArenaStringPtr lens_brand_;
    ::google::protobuf::internal::ArenaStringPtr lens_model_;
    ::google::protobuf::internal::ArenaStringPtr lens_profile_;
    ::google::protobuf::internal::ArenaStringPtr imu_orientation_;
    ::google::protobuf::internal::ArenaStringPtr additional_data_;
    ::gyroflow::Quaternion* imu_rotation_;
    ::gyroflow::Quaternion* quats_rotation_;
    ::uint32_t pixel_pitch_nm_;
    ::uint32_t sensor_pixel_width_;
    ::uint32_t sensor_pixel_height_;
    float crop_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class EISData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.EISData) */ {
 public:
  inline EISData() : EISData(nullptr) {}
  ~EISData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EISData(::google::protobuf::internal::ConstantInitialized);

  inline EISData(const EISData& from)
      : EISData(nullptr, from) {}
  EISData(EISData&& from) noexcept
    : EISData() {
    *this = ::std::move(from);
  }

  inline EISData& operator=(const EISData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EISData& operator=(EISData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EISData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EISData* internal_default_instance() {
    return reinterpret_cast<const EISData*>(
               &_EISData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EISData& a, EISData& b) {
    a.Swap(&b);
  }
  inline void Swap(EISData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EISData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EISData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EISData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EISData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EISData& from) {
    EISData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EISData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.EISData";
  }
  protected:
  explicit EISData(::google::protobuf::Arena* arena);
  EISData(::google::protobuf::Arena* arena, const EISData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using EISDataType = EISData_EISDataType;
  static constexpr EISDataType QUATERNION = EISData_EISDataType_QUATERNION;
  static constexpr EISDataType MESH_WARP = EISData_EISDataType_MESH_WARP;
  static constexpr EISDataType MATRIX_4X4 = EISData_EISDataType_MATRIX_4X4;
  static inline bool EISDataType_IsValid(int value) {
    return EISData_EISDataType_IsValid(value);
  }
  static constexpr EISDataType EISDataType_MIN = EISData_EISDataType_EISDataType_MIN;
  static constexpr EISDataType EISDataType_MAX = EISData_EISDataType_EISDataType_MAX;
  static constexpr int EISDataType_ARRAYSIZE = EISData_EISDataType_EISDataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EISDataType_descriptor() {
    return EISData_EISDataType_descriptor();
  }
  template <typename T>
  static inline const std::string& EISDataType_Name(T value) {
    return EISData_EISDataType_Name(value);
  }
  static inline bool EISDataType_Parse(absl::string_view name, EISDataType* value) {
    return EISData_EISDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMatrix4X4FieldNumber = 5,
    kQuaternionFieldNumber = 3,
    kMeshWarpFieldNumber = 4,
    kSampleTimestampUsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated float matrix_4x4 = 5;
  int matrix_4x4_size() const;
  private:
  int _internal_matrix_4x4_size() const;

  public:
  void clear_matrix_4x4() ;
  float matrix_4x4(int index) const;
  void set_matrix_4x4(int index, float value);
  void add_matrix_4x4(float value);
  const ::google::protobuf::RepeatedField<float>& matrix_4x4() const;
  ::google::protobuf::RepeatedField<float>* mutable_matrix_4x4();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_matrix_4x4() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_matrix_4x4();

  public:
  // optional .gyroflow.Quaternion quaternion = 3;
  bool has_quaternion() const;
  void clear_quaternion() ;
  const ::gyroflow::Quaternion& quaternion() const;
  PROTOBUF_NODISCARD ::gyroflow::Quaternion* release_quaternion();
  ::gyroflow::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::gyroflow::Quaternion* value);
  void unsafe_arena_set_allocated_quaternion(::gyroflow::Quaternion* value);
  ::gyroflow::Quaternion* unsafe_arena_release_quaternion();

  private:
  const ::gyroflow::Quaternion& _internal_quaternion() const;
  ::gyroflow::Quaternion* _internal_mutable_quaternion();

  public:
  // optional .gyroflow.MeshWarpData mesh_warp = 4;
  bool has_mesh_warp() const;
  void clear_mesh_warp() ;
  const ::gyroflow::MeshWarpData& mesh_warp() const;
  PROTOBUF_NODISCARD ::gyroflow::MeshWarpData* release_mesh_warp();
  ::gyroflow::MeshWarpData* mutable_mesh_warp();
  void set_allocated_mesh_warp(::gyroflow::MeshWarpData* value);
  void unsafe_arena_set_allocated_mesh_warp(::gyroflow::MeshWarpData* value);
  ::gyroflow::MeshWarpData* unsafe_arena_release_mesh_warp();

  private:
  const ::gyroflow::MeshWarpData& _internal_mesh_warp() const;
  ::gyroflow::MeshWarpData* _internal_mutable_mesh_warp();

  public:
  // optional double sample_timestamp_us = 1;
  bool has_sample_timestamp_us() const;
  void clear_sample_timestamp_us() ;
  double sample_timestamp_us() const;
  void set_sample_timestamp_us(double value);

  private:
  double _internal_sample_timestamp_us() const;
  void _internal_set_sample_timestamp_us(double value);

  public:
  // .gyroflow.EISData.EISDataType type = 2;
  void clear_type() ;
  ::gyroflow::EISData_EISDataType type() const;
  void set_type(::gyroflow::EISData_EISDataType value);

  private:
  ::gyroflow::EISData_EISDataType _internal_type() const;
  void _internal_set_type(::gyroflow::EISData_EISDataType value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.EISData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> matrix_4x4_;
    ::gyroflow::Quaternion* quaternion_;
    ::gyroflow::MeshWarpData* mesh_warp_;
    double sample_timestamp_us_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class Header final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header(::google::protobuf::internal::ConstantInitialized);

  inline Header(const Header& from)
      : Header(nullptr, from) {}
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.Header";
  }
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  Header(::google::protobuf::Arena* arena, const Header& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CameraMetadata = Header_CameraMetadata;
  using ClipMetadata = Header_ClipMetadata;

  // accessors -------------------------------------------------------

  enum : int {
    kCameraFieldNumber = 1,
    kClipFieldNumber = 2,
  };
  // .gyroflow.Header.CameraMetadata camera = 1;
  bool has_camera() const;
  void clear_camera() ;
  const ::gyroflow::Header_CameraMetadata& camera() const;
  PROTOBUF_NODISCARD ::gyroflow::Header_CameraMetadata* release_camera();
  ::gyroflow::Header_CameraMetadata* mutable_camera();
  void set_allocated_camera(::gyroflow::Header_CameraMetadata* value);
  void unsafe_arena_set_allocated_camera(::gyroflow::Header_CameraMetadata* value);
  ::gyroflow::Header_CameraMetadata* unsafe_arena_release_camera();

  private:
  const ::gyroflow::Header_CameraMetadata& _internal_camera() const;
  ::gyroflow::Header_CameraMetadata* _internal_mutable_camera();

  public:
  // .gyroflow.Header.ClipMetadata clip = 2;
  bool has_clip() const;
  void clear_clip() ;
  const ::gyroflow::Header_ClipMetadata& clip() const;
  PROTOBUF_NODISCARD ::gyroflow::Header_ClipMetadata* release_clip();
  ::gyroflow::Header_ClipMetadata* mutable_clip();
  void set_allocated_clip(::gyroflow::Header_ClipMetadata* value);
  void unsafe_arena_set_allocated_clip(::gyroflow::Header_ClipMetadata* value);
  ::gyroflow::Header_ClipMetadata* unsafe_arena_release_clip();

  private:
  const ::gyroflow::Header_ClipMetadata& _internal_clip() const;
  ::gyroflow::Header_ClipMetadata* _internal_mutable_clip();

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.Header)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::gyroflow::Header_CameraMetadata* camera_;
    ::gyroflow::Header_ClipMetadata* clip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class FrameMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.FrameMetadata) */ {
 public:
  inline FrameMetadata() : FrameMetadata(nullptr) {}
  ~FrameMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FrameMetadata(::google::protobuf::internal::ConstantInitialized);

  inline FrameMetadata(const FrameMetadata& from)
      : FrameMetadata(nullptr, from) {}
  FrameMetadata(FrameMetadata&& from) noexcept
    : FrameMetadata() {
    *this = ::std::move(from);
  }

  inline FrameMetadata& operator=(const FrameMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameMetadata& operator=(FrameMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameMetadata* internal_default_instance() {
    return reinterpret_cast<const FrameMetadata*>(
               &_FrameMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FrameMetadata& a, FrameMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FrameMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FrameMetadata& from) {
    FrameMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FrameMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.FrameMetadata";
  }
  protected:
  explicit FrameMetadata(::google::protobuf::Arena* arena);
  FrameMetadata(::google::protobuf::Arena* arena, const FrameMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLensFieldNumber = 16,
    kImuFieldNumber = 17,
    kQuaternionsFieldNumber = 18,
    kOisFieldNumber = 19,
    kIbisFieldNumber = 20,
    kEisFieldNumber = 21,
    kStartTimestampUsFieldNumber = 1,
    kEndTimestampUsFieldNumber = 2,
    kFrameNumberFieldNumber = 3,
    kIsoFieldNumber = 4,
    kExposureTimeUsFieldNumber = 5,
    kWhiteBalanceKelvinFieldNumber = 6,
    kWhiteBalanceTintFieldNumber = 7,
    kDigitalZoomRatioFieldNumber = 8,
    kShutterSpeedNumeratorFieldNumber = 9,
    kShutterSpeedDenumeratorFieldNumber = 10,
    kShutterAngleDegreesFieldNumber = 11,
    kCropXFieldNumber = 12,
    kCropYFieldNumber = 13,
    kCropWidthFieldNumber = 14,
    kCropHeightFieldNumber = 15,
  };
  // repeated .gyroflow.LensData lens = 16;
  int lens_size() const;
  private:
  int _internal_lens_size() const;

  public:
  void clear_lens() ;
  ::gyroflow::LensData* mutable_lens(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::LensData >*
      mutable_lens();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>& _internal_lens() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>* _internal_mutable_lens();
  public:
  const ::gyroflow::LensData& lens(int index) const;
  ::gyroflow::LensData* add_lens();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::LensData >&
      lens() const;
  // repeated .gyroflow.IMUData imu = 17;
  int imu_size() const;
  private:
  int _internal_imu_size() const;

  public:
  void clear_imu() ;
  ::gyroflow::IMUData* mutable_imu(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::IMUData >*
      mutable_imu();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>& _internal_imu() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>* _internal_mutable_imu();
  public:
  const ::gyroflow::IMUData& imu(int index) const;
  ::gyroflow::IMUData* add_imu();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::IMUData >&
      imu() const;
  // repeated .gyroflow.QuaternionData quaternions = 18;
  int quaternions_size() const;
  private:
  int _internal_quaternions_size() const;

  public:
  void clear_quaternions() ;
  ::gyroflow::QuaternionData* mutable_quaternions(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::QuaternionData >*
      mutable_quaternions();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>& _internal_quaternions() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>* _internal_mutable_quaternions();
  public:
  const ::gyroflow::QuaternionData& quaternions(int index) const;
  ::gyroflow::QuaternionData* add_quaternions();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::QuaternionData >&
      quaternions() const;
  // repeated .gyroflow.LensOISData ois = 19;
  int ois_size() const;
  private:
  int _internal_ois_size() const;

  public:
  void clear_ois() ;
  ::gyroflow::LensOISData* mutable_ois(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::LensOISData >*
      mutable_ois();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>& _internal_ois() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>* _internal_mutable_ois();
  public:
  const ::gyroflow::LensOISData& ois(int index) const;
  ::gyroflow::LensOISData* add_ois();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::LensOISData >&
      ois() const;
  // repeated .gyroflow.IBISData ibis = 20;
  int ibis_size() const;
  private:
  int _internal_ibis_size() const;

  public:
  void clear_ibis() ;
  ::gyroflow::IBISData* mutable_ibis(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::IBISData >*
      mutable_ibis();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>& _internal_ibis() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>* _internal_mutable_ibis();
  public:
  const ::gyroflow::IBISData& ibis(int index) const;
  ::gyroflow::IBISData* add_ibis();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::IBISData >&
      ibis() const;
  // repeated .gyroflow.EISData eis = 21;
  int eis_size() const;
  private:
  int _internal_eis_size() const;

  public:
  void clear_eis() ;
  ::gyroflow::EISData* mutable_eis(int index);
  ::google::protobuf::RepeatedPtrField< ::gyroflow::EISData >*
      mutable_eis();
  private:
  const ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>& _internal_eis() const;
  ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>* _internal_mutable_eis();
  public:
  const ::gyroflow::EISData& eis(int index) const;
  ::gyroflow::EISData* add_eis();
  const ::google::protobuf::RepeatedPtrField< ::gyroflow::EISData >&
      eis() const;
  // double start_timestamp_us = 1;
  void clear_start_timestamp_us() ;
  double start_timestamp_us() const;
  void set_start_timestamp_us(double value);

  private:
  double _internal_start_timestamp_us() const;
  void _internal_set_start_timestamp_us(double value);

  public:
  // double end_timestamp_us = 2;
  void clear_end_timestamp_us() ;
  double end_timestamp_us() const;
  void set_end_timestamp_us(double value);

  private:
  double _internal_end_timestamp_us() const;
  void _internal_set_end_timestamp_us(double value);

  public:
  // uint32 frame_number = 3;
  void clear_frame_number() ;
  ::uint32_t frame_number() const;
  void set_frame_number(::uint32_t value);

  private:
  ::uint32_t _internal_frame_number() const;
  void _internal_set_frame_number(::uint32_t value);

  public:
  // optional uint32 iso = 4;
  bool has_iso() const;
  void clear_iso() ;
  ::uint32_t iso() const;
  void set_iso(::uint32_t value);

  private:
  ::uint32_t _internal_iso() const;
  void _internal_set_iso(::uint32_t value);

  public:
  // optional float exposure_time_us = 5;
  bool has_exposure_time_us() const;
  void clear_exposure_time_us() ;
  float exposure_time_us() const;
  void set_exposure_time_us(float value);

  private:
  float _internal_exposure_time_us() const;
  void _internal_set_exposure_time_us(float value);

  public:
  // optional uint32 white_balance_kelvin = 6;
  bool has_white_balance_kelvin() const;
  void clear_white_balance_kelvin() ;
  ::uint32_t white_balance_kelvin() const;
  void set_white_balance_kelvin(::uint32_t value);

  private:
  ::uint32_t _internal_white_balance_kelvin() const;
  void _internal_set_white_balance_kelvin(::uint32_t value);

  public:
  // optional float white_balance_tint = 7;
  bool has_white_balance_tint() const;
  void clear_white_balance_tint() ;
  float white_balance_tint() const;
  void set_white_balance_tint(float value);

  private:
  float _internal_white_balance_tint() const;
  void _internal_set_white_balance_tint(float value);

  public:
  // optional float digital_zoom_ratio = 8;
  bool has_digital_zoom_ratio() const;
  void clear_digital_zoom_ratio() ;
  float digital_zoom_ratio() const;
  void set_digital_zoom_ratio(float value);

  private:
  float _internal_digital_zoom_ratio() const;
  void _internal_set_digital_zoom_ratio(float value);

  public:
  // optional int32 shutter_speed_numerator = 9;
  bool has_shutter_speed_numerator() const;
  void clear_shutter_speed_numerator() ;
  ::int32_t shutter_speed_numerator() const;
  void set_shutter_speed_numerator(::int32_t value);

  private:
  ::int32_t _internal_shutter_speed_numerator() const;
  void _internal_set_shutter_speed_numerator(::int32_t value);

  public:
  // optional int32 shutter_speed_denumerator = 10;
  bool has_shutter_speed_denumerator() const;
  void clear_shutter_speed_denumerator() ;
  ::int32_t shutter_speed_denumerator() const;
  void set_shutter_speed_denumerator(::int32_t value);

  private:
  ::int32_t _internal_shutter_speed_denumerator() const;
  void _internal_set_shutter_speed_denumerator(::int32_t value);

  public:
  // optional float shutter_angle_degrees = 11;
  bool has_shutter_angle_degrees() const;
  void clear_shutter_angle_degrees() ;
  float shutter_angle_degrees() const;
  void set_shutter_angle_degrees(float value);

  private:
  float _internal_shutter_angle_degrees() const;
  void _internal_set_shutter_angle_degrees(float value);

  public:
  // optional float crop_x = 12;
  bool has_crop_x() const;
  void clear_crop_x() ;
  float crop_x() const;
  void set_crop_x(float value);

  private:
  float _internal_crop_x() const;
  void _internal_set_crop_x(float value);

  public:
  // optional float crop_y = 13;
  bool has_crop_y() const;
  void clear_crop_y() ;
  float crop_y() const;
  void set_crop_y(float value);

  private:
  float _internal_crop_y() const;
  void _internal_set_crop_y(float value);

  public:
  // optional float crop_width = 14;
  bool has_crop_width() const;
  void clear_crop_width() ;
  float crop_width() const;
  void set_crop_width(float value);

  private:
  float _internal_crop_width() const;
  void _internal_set_crop_width(float value);

  public:
  // optional float crop_height = 15;
  bool has_crop_height() const;
  void clear_crop_height() ;
  float crop_height() const;
  void set_crop_height(float value);

  private:
  float _internal_crop_height() const;
  void _internal_set_crop_height(float value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.FrameMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 21, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::LensData > lens_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::IMUData > imu_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::QuaternionData > quaternions_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::LensOISData > ois_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::IBISData > ibis_;
    ::google::protobuf::RepeatedPtrField< ::gyroflow::EISData > eis_;
    double start_timestamp_us_;
    double end_timestamp_us_;
    ::uint32_t frame_number_;
    ::uint32_t iso_;
    float exposure_time_us_;
    ::uint32_t white_balance_kelvin_;
    float white_balance_tint_;
    float digital_zoom_ratio_;
    ::int32_t shutter_speed_numerator_;
    ::int32_t shutter_speed_denumerator_;
    float shutter_angle_degrees_;
    float crop_x_;
    float crop_y_;
    float crop_width_;
    float crop_height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};// -------------------------------------------------------------------

class Main final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gyroflow.Main) */ {
 public:
  inline Main() : Main(nullptr) {}
  ~Main() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Main(::google::protobuf::internal::ConstantInitialized);

  inline Main(const Main& from)
      : Main(nullptr, from) {}
  Main(Main&& from) noexcept
    : Main() {
    *this = ::std::move(from);
  }

  inline Main& operator=(const Main& from) {
    CopyFrom(from);
    return *this;
  }
  inline Main& operator=(Main&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Main& default_instance() {
    return *internal_default_instance();
  }
  static inline const Main* internal_default_instance() {
    return reinterpret_cast<const Main*>(
               &_Main_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Main& a, Main& b) {
    a.Swap(&b);
  }
  inline void Swap(Main* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Main* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Main* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Main>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Main& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Main& from) {
    Main::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Main* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gyroflow.Main";
  }
  protected:
  explicit Main(::google::protobuf::Arena* arena);
  Main(::google::protobuf::Arena* arena, const Main& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMagicStringFieldNumber = 1,
    kHeaderFieldNumber = 3,
    kFrameFieldNumber = 4,
    kProtocolVersionFieldNumber = 2,
  };
  // string magic_string = 1;
  void clear_magic_string() ;
  const std::string& magic_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_magic_string(Arg_&& arg, Args_... args);
  std::string* mutable_magic_string();
  PROTOBUF_NODISCARD std::string* release_magic_string();
  void set_allocated_magic_string(std::string* value);

  private:
  const std::string& _internal_magic_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_magic_string(
      const std::string& value);
  std::string* _internal_mutable_magic_string();

  public:
  // .gyroflow.Header header = 3;
  bool has_header() const;
  void clear_header() ;
  const ::gyroflow::Header& header() const;
  PROTOBUF_NODISCARD ::gyroflow::Header* release_header();
  ::gyroflow::Header* mutable_header();
  void set_allocated_header(::gyroflow::Header* value);
  void unsafe_arena_set_allocated_header(::gyroflow::Header* value);
  ::gyroflow::Header* unsafe_arena_release_header();

  private:
  const ::gyroflow::Header& _internal_header() const;
  ::gyroflow::Header* _internal_mutable_header();

  public:
  // .gyroflow.FrameMetadata frame = 4;
  bool has_frame() const;
  void clear_frame() ;
  const ::gyroflow::FrameMetadata& frame() const;
  PROTOBUF_NODISCARD ::gyroflow::FrameMetadata* release_frame();
  ::gyroflow::FrameMetadata* mutable_frame();
  void set_allocated_frame(::gyroflow::FrameMetadata* value);
  void unsafe_arena_set_allocated_frame(::gyroflow::FrameMetadata* value);
  ::gyroflow::FrameMetadata* unsafe_arena_release_frame();

  private:
  const ::gyroflow::FrameMetadata& _internal_frame() const;
  ::gyroflow::FrameMetadata* _internal_mutable_frame();

  public:
  // uint32 protocol_version = 2;
  void clear_protocol_version() ;
  ::uint32_t protocol_version() const;
  void set_protocol_version(::uint32_t value);

  private:
  ::uint32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:gyroflow.Main)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr magic_string_;
    ::gyroflow::Header* header_;
    ::gyroflow::FrameMetadata* frame_;
    ::uint32_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fgyroflow_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Main

// string magic_string = 1;
inline void Main::clear_magic_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magic_string_.ClearToEmpty();
}
inline const std::string& Main::magic_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Main.magic_string)
  return _internal_magic_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Main::set_magic_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.magic_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Main.magic_string)
}
inline std::string* Main::mutable_magic_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_magic_string();
  // @@protoc_insertion_point(field_mutable:gyroflow.Main.magic_string)
  return _s;
}
inline const std::string& Main::_internal_magic_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.magic_string_.Get();
}
inline void Main::_internal_set_magic_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.magic_string_.Set(value, GetArena());
}
inline std::string* Main::_internal_mutable_magic_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.magic_string_.Mutable( GetArena());
}
inline std::string* Main::release_magic_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Main.magic_string)
  return _impl_.magic_string_.Release();
}
inline void Main::set_allocated_magic_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magic_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.magic_string_.IsDefault()) {
          _impl_.magic_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Main.magic_string)
}

// uint32 protocol_version = 2;
inline void Main::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = 0u;
}
inline ::uint32_t Main::protocol_version() const {
  // @@protoc_insertion_point(field_get:gyroflow.Main.protocol_version)
  return _internal_protocol_version();
}
inline void Main::set_protocol_version(::uint32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:gyroflow.Main.protocol_version)
}
inline ::uint32_t Main::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void Main::_internal_set_protocol_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_version_ = value;
}

// .gyroflow.Header header = 3;
inline bool Main::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void Main::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gyroflow::Header& Main::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Header&>(::gyroflow::_Header_default_instance_);
}
inline const ::gyroflow::Header& Main::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Main.header)
  return _internal_header();
}
inline void Main::unsafe_arena_set_allocated_header(::gyroflow::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::gyroflow::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Main.header)
}
inline ::gyroflow::Header* Main::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Header* Main::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Main.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::gyroflow::Header* Main::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::gyroflow::Header*>(p);
  }
  return _impl_.header_;
}
inline ::gyroflow::Header* Main::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:gyroflow.Main.header)
  return _msg;
}
inline void Main::set_allocated_header(::gyroflow::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Header*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Header*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::gyroflow::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Main.header)
}

// .gyroflow.FrameMetadata frame = 4;
inline bool Main::has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_ != nullptr);
  return value;
}
inline void Main::clear_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.frame_ != nullptr) _impl_.frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gyroflow::FrameMetadata& Main::_internal_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::FrameMetadata* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::FrameMetadata&>(::gyroflow::_FrameMetadata_default_instance_);
}
inline const ::gyroflow::FrameMetadata& Main::frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Main.frame)
  return _internal_frame();
}
inline void Main::unsafe_arena_set_allocated_frame(::gyroflow::FrameMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = reinterpret_cast<::gyroflow::FrameMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Main.frame)
}
inline ::gyroflow::FrameMetadata* Main::release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::FrameMetadata* released = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::FrameMetadata* Main::unsafe_arena_release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Main.frame)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::FrameMetadata* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::gyroflow::FrameMetadata* Main::_internal_mutable_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::FrameMetadata>(GetArena());
    _impl_.frame_ = reinterpret_cast<::gyroflow::FrameMetadata*>(p);
  }
  return _impl_.frame_;
}
inline ::gyroflow::FrameMetadata* Main::mutable_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::FrameMetadata* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:gyroflow.Main.frame)
  return _msg;
}
inline void Main::set_allocated_frame(::gyroflow::FrameMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::FrameMetadata*>(_impl_.frame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::FrameMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.frame_ = reinterpret_cast<::gyroflow::FrameMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Main.frame)
}

// -------------------------------------------------------------------

// Header_CameraMetadata

// string camera_brand = 1;
inline void Header_CameraMetadata::clear_camera_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_brand_.ClearToEmpty();
}
inline const std::string& Header_CameraMetadata::camera_brand() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.camera_brand)
  return _internal_camera_brand();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_camera_brand(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.camera_brand_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.camera_brand)
}
inline std::string* Header_CameraMetadata::mutable_camera_brand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_camera_brand();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.camera_brand)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_camera_brand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camera_brand_.Get();
}
inline void Header_CameraMetadata::_internal_set_camera_brand(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.camera_brand_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_camera_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.camera_brand_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_camera_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.camera_brand)
  return _impl_.camera_brand_.Release();
}
inline void Header_CameraMetadata::set_allocated_camera_brand(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_brand_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_brand_.IsDefault()) {
          _impl_.camera_brand_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.camera_brand)
}

// string camera_model = 2;
inline void Header_CameraMetadata::clear_camera_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_model_.ClearToEmpty();
}
inline const std::string& Header_CameraMetadata::camera_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.camera_model)
  return _internal_camera_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_camera_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.camera_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.camera_model)
}
inline std::string* Header_CameraMetadata::mutable_camera_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_camera_model();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.camera_model)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_camera_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camera_model_.Get();
}
inline void Header_CameraMetadata::_internal_set_camera_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.camera_model_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_camera_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.camera_model_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_camera_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.camera_model)
  return _impl_.camera_model_.Release();
}
inline void Header_CameraMetadata::set_allocated_camera_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_model_.IsDefault()) {
          _impl_.camera_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.camera_model)
}

// optional string camera_serial_number = 3;
inline bool Header_CameraMetadata::has_camera_serial_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_camera_serial_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_serial_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header_CameraMetadata::camera_serial_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.camera_serial_number)
  return _internal_camera_serial_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_camera_serial_number(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.camera_serial_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.camera_serial_number)
}
inline std::string* Header_CameraMetadata::mutable_camera_serial_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_camera_serial_number();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.camera_serial_number)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_camera_serial_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camera_serial_number_.Get();
}
inline void Header_CameraMetadata::_internal_set_camera_serial_number(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.camera_serial_number_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_camera_serial_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.camera_serial_number_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_camera_serial_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.camera_serial_number)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.camera_serial_number_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.camera_serial_number_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_CameraMetadata::set_allocated_camera_serial_number(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_serial_number_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.camera_serial_number_.IsDefault()) {
          _impl_.camera_serial_number_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.camera_serial_number)
}

// optional string firmware_version = 4;
inline bool Header_CameraMetadata::has_firmware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firmware_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Header_CameraMetadata::firmware_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.firmware_version)
  return _internal_firmware_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_firmware_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.firmware_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.firmware_version)
}
inline std::string* Header_CameraMetadata::mutable_firmware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.firmware_version)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_firmware_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firmware_version_.Get();
}
inline void Header_CameraMetadata::_internal_set_firmware_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.firmware_version_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.firmware_version_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.firmware_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.firmware_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.firmware_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_CameraMetadata::set_allocated_firmware_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.firmware_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.firmware_version_.IsDefault()) {
          _impl_.firmware_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.firmware_version)
}

// string lens_brand = 5;
inline void Header_CameraMetadata::clear_lens_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_brand_.ClearToEmpty();
}
inline const std::string& Header_CameraMetadata::lens_brand() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.lens_brand)
  return _internal_lens_brand();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_lens_brand(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lens_brand_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.lens_brand)
}
inline std::string* Header_CameraMetadata::mutable_lens_brand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lens_brand();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.lens_brand)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_lens_brand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lens_brand_.Get();
}
inline void Header_CameraMetadata::_internal_set_lens_brand(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lens_brand_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_lens_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lens_brand_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_lens_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.lens_brand)
  return _impl_.lens_brand_.Release();
}
inline void Header_CameraMetadata::set_allocated_lens_brand(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_brand_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lens_brand_.IsDefault()) {
          _impl_.lens_brand_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.lens_brand)
}

// string lens_model = 6;
inline void Header_CameraMetadata::clear_lens_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_model_.ClearToEmpty();
}
inline const std::string& Header_CameraMetadata::lens_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.lens_model)
  return _internal_lens_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_lens_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lens_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.lens_model)
}
inline std::string* Header_CameraMetadata::mutable_lens_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lens_model();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.lens_model)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_lens_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lens_model_.Get();
}
inline void Header_CameraMetadata::_internal_set_lens_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lens_model_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_lens_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lens_model_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_lens_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.lens_model)
  return _impl_.lens_model_.Release();
}
inline void Header_CameraMetadata::set_allocated_lens_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lens_model_.IsDefault()) {
          _impl_.lens_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.lens_model)
}

// uint32 pixel_pitch_nm = 7;
inline void Header_CameraMetadata::clear_pixel_pitch_nm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pixel_pitch_nm_ = 0u;
}
inline ::uint32_t Header_CameraMetadata::pixel_pitch_nm() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.pixel_pitch_nm)
  return _internal_pixel_pitch_nm();
}
inline void Header_CameraMetadata::set_pixel_pitch_nm(::uint32_t value) {
  _internal_set_pixel_pitch_nm(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.pixel_pitch_nm)
}
inline ::uint32_t Header_CameraMetadata::_internal_pixel_pitch_nm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pixel_pitch_nm_;
}
inline void Header_CameraMetadata::_internal_set_pixel_pitch_nm(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pixel_pitch_nm_ = value;
}

// uint32 sensor_pixel_width = 8;
inline void Header_CameraMetadata::clear_sensor_pixel_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_pixel_width_ = 0u;
}
inline ::uint32_t Header_CameraMetadata::sensor_pixel_width() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.sensor_pixel_width)
  return _internal_sensor_pixel_width();
}
inline void Header_CameraMetadata::set_sensor_pixel_width(::uint32_t value) {
  _internal_set_sensor_pixel_width(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.sensor_pixel_width)
}
inline ::uint32_t Header_CameraMetadata::_internal_sensor_pixel_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_pixel_width_;
}
inline void Header_CameraMetadata::_internal_set_sensor_pixel_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sensor_pixel_width_ = value;
}

// uint32 sensor_pixel_height = 9;
inline void Header_CameraMetadata::clear_sensor_pixel_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_pixel_height_ = 0u;
}
inline ::uint32_t Header_CameraMetadata::sensor_pixel_height() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.sensor_pixel_height)
  return _internal_sensor_pixel_height();
}
inline void Header_CameraMetadata::set_sensor_pixel_height(::uint32_t value) {
  _internal_set_sensor_pixel_height(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.sensor_pixel_height)
}
inline ::uint32_t Header_CameraMetadata::_internal_sensor_pixel_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_pixel_height_;
}
inline void Header_CameraMetadata::_internal_set_sensor_pixel_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sensor_pixel_height_ = value;
}

// optional float crop_factor = 10;
inline bool Header_CameraMetadata::has_crop_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_crop_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crop_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Header_CameraMetadata::crop_factor() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.crop_factor)
  return _internal_crop_factor();
}
inline void Header_CameraMetadata::set_crop_factor(float value) {
  _internal_set_crop_factor(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.crop_factor)
}
inline float Header_CameraMetadata::_internal_crop_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crop_factor_;
}
inline void Header_CameraMetadata::_internal_set_crop_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.crop_factor_ = value;
}

// optional string lens_profile = 11;
inline bool Header_CameraMetadata::has_lens_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_lens_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_profile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Header_CameraMetadata::lens_profile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.lens_profile)
  return _internal_lens_profile();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_lens_profile(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lens_profile_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.lens_profile)
}
inline std::string* Header_CameraMetadata::mutable_lens_profile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lens_profile();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.lens_profile)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_lens_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lens_profile_.Get();
}
inline void Header_CameraMetadata::_internal_set_lens_profile(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lens_profile_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_lens_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.lens_profile_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_lens_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.lens_profile)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.lens_profile_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lens_profile_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_CameraMetadata::set_allocated_lens_profile(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.lens_profile_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lens_profile_.IsDefault()) {
          _impl_.lens_profile_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.lens_profile)
}

// optional string imu_orientation = 12;
inline bool Header_CameraMetadata::has_imu_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_imu_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imu_orientation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Header_CameraMetadata::imu_orientation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.imu_orientation)
  return _internal_imu_orientation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_imu_orientation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.imu_orientation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.imu_orientation)
}
inline std::string* Header_CameraMetadata::mutable_imu_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_imu_orientation();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.imu_orientation)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_imu_orientation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imu_orientation_.Get();
}
inline void Header_CameraMetadata::_internal_set_imu_orientation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.imu_orientation_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_imu_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.imu_orientation_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_imu_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.imu_orientation)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.imu_orientation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imu_orientation_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_CameraMetadata::set_allocated_imu_orientation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.imu_orientation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.imu_orientation_.IsDefault()) {
          _impl_.imu_orientation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.imu_orientation)
}

// optional .gyroflow.Quaternion imu_rotation = 13;
inline bool Header_CameraMetadata::has_imu_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.imu_rotation_ != nullptr);
  return value;
}
inline void Header_CameraMetadata::clear_imu_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.imu_rotation_ != nullptr) _impl_.imu_rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::gyroflow::Quaternion& Header_CameraMetadata::_internal_imu_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Quaternion* p = _impl_.imu_rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Quaternion&>(::gyroflow::_Quaternion_default_instance_);
}
inline const ::gyroflow::Quaternion& Header_CameraMetadata::imu_rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.imu_rotation)
  return _internal_imu_rotation();
}
inline void Header_CameraMetadata::unsafe_arena_set_allocated_imu_rotation(::gyroflow::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.imu_rotation_);
  }
  _impl_.imu_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Header.CameraMetadata.imu_rotation)
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::release_imu_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::gyroflow::Quaternion* released = _impl_.imu_rotation_;
  _impl_.imu_rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::unsafe_arena_release_imu_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.imu_rotation)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::gyroflow::Quaternion* temp = _impl_.imu_rotation_;
  _impl_.imu_rotation_ = nullptr;
  return temp;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::_internal_mutable_imu_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.imu_rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Quaternion>(GetArena());
    _impl_.imu_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(p);
  }
  return _impl_.imu_rotation_;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::mutable_imu_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Quaternion* _msg = _internal_mutable_imu_rotation();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.imu_rotation)
  return _msg;
}
inline void Header_CameraMetadata::set_allocated_imu_rotation(::gyroflow::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Quaternion*>(_impl_.imu_rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.imu_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.imu_rotation)
}

// optional .gyroflow.Quaternion quats_rotation = 14;
inline bool Header_CameraMetadata::has_quats_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quats_rotation_ != nullptr);
  return value;
}
inline void Header_CameraMetadata::clear_quats_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.quats_rotation_ != nullptr) _impl_.quats_rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::gyroflow::Quaternion& Header_CameraMetadata::_internal_quats_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Quaternion* p = _impl_.quats_rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Quaternion&>(::gyroflow::_Quaternion_default_instance_);
}
inline const ::gyroflow::Quaternion& Header_CameraMetadata::quats_rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.quats_rotation)
  return _internal_quats_rotation();
}
inline void Header_CameraMetadata::unsafe_arena_set_allocated_quats_rotation(::gyroflow::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quats_rotation_);
  }
  _impl_.quats_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Header.CameraMetadata.quats_rotation)
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::release_quats_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::gyroflow::Quaternion* released = _impl_.quats_rotation_;
  _impl_.quats_rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::unsafe_arena_release_quats_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.quats_rotation)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::gyroflow::Quaternion* temp = _impl_.quats_rotation_;
  _impl_.quats_rotation_ = nullptr;
  return temp;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::_internal_mutable_quats_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.quats_rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Quaternion>(GetArena());
    _impl_.quats_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(p);
  }
  return _impl_.quats_rotation_;
}
inline ::gyroflow::Quaternion* Header_CameraMetadata::mutable_quats_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Quaternion* _msg = _internal_mutable_quats_rotation();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.quats_rotation)
  return _msg;
}
inline void Header_CameraMetadata::set_allocated_quats_rotation(::gyroflow::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Quaternion*>(_impl_.quats_rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.quats_rotation_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.quats_rotation)
}

// optional string additional_data = 15;
inline bool Header_CameraMetadata::has_additional_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Header_CameraMetadata::clear_additional_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Header_CameraMetadata::additional_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.CameraMetadata.additional_data)
  return _internal_additional_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_CameraMetadata::set_additional_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.additional_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.CameraMetadata.additional_data)
}
inline std::string* Header_CameraMetadata::mutable_additional_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_additional_data();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.CameraMetadata.additional_data)
  return _s;
}
inline const std::string& Header_CameraMetadata::_internal_additional_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.additional_data_.Get();
}
inline void Header_CameraMetadata::_internal_set_additional_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.additional_data_.Set(value, GetArena());
}
inline std::string* Header_CameraMetadata::_internal_mutable_additional_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.additional_data_.Mutable( GetArena());
}
inline std::string* Header_CameraMetadata::release_additional_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.CameraMetadata.additional_data)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.additional_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.additional_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_CameraMetadata::set_allocated_additional_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.additional_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.additional_data_.IsDefault()) {
          _impl_.additional_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.CameraMetadata.additional_data)
}

// -------------------------------------------------------------------

// Header_ClipMetadata

// uint32 frame_width = 1;
inline void Header_ClipMetadata::clear_frame_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_width_ = 0u;
}
inline ::uint32_t Header_ClipMetadata::frame_width() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.frame_width)
  return _internal_frame_width();
}
inline void Header_ClipMetadata::set_frame_width(::uint32_t value) {
  _internal_set_frame_width(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.frame_width)
}
inline ::uint32_t Header_ClipMetadata::_internal_frame_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_width_;
}
inline void Header_ClipMetadata::_internal_set_frame_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_width_ = value;
}

// uint32 frame_height = 2;
inline void Header_ClipMetadata::clear_frame_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_height_ = 0u;
}
inline ::uint32_t Header_ClipMetadata::frame_height() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.frame_height)
  return _internal_frame_height();
}
inline void Header_ClipMetadata::set_frame_height(::uint32_t value) {
  _internal_set_frame_height(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.frame_height)
}
inline ::uint32_t Header_ClipMetadata::_internal_frame_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_height_;
}
inline void Header_ClipMetadata::_internal_set_frame_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_height_ = value;
}

// float duration_us = 3;
inline void Header_ClipMetadata::clear_duration_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_us_ = 0;
}
inline float Header_ClipMetadata::duration_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.duration_us)
  return _internal_duration_us();
}
inline void Header_ClipMetadata::set_duration_us(float value) {
  _internal_set_duration_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.duration_us)
}
inline float Header_ClipMetadata::_internal_duration_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_us_;
}
inline void Header_ClipMetadata::_internal_set_duration_us(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_us_ = value;
}

// float record_frame_rate = 4;
inline void Header_ClipMetadata::clear_record_frame_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.record_frame_rate_ = 0;
}
inline float Header_ClipMetadata::record_frame_rate() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.record_frame_rate)
  return _internal_record_frame_rate();
}
inline void Header_ClipMetadata::set_record_frame_rate(float value) {
  _internal_set_record_frame_rate(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.record_frame_rate)
}
inline float Header_ClipMetadata::_internal_record_frame_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.record_frame_rate_;
}
inline void Header_ClipMetadata::_internal_set_record_frame_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.record_frame_rate_ = value;
}

// float sensor_frame_rate = 5;
inline void Header_ClipMetadata::clear_sensor_frame_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_frame_rate_ = 0;
}
inline float Header_ClipMetadata::sensor_frame_rate() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.sensor_frame_rate)
  return _internal_sensor_frame_rate();
}
inline void Header_ClipMetadata::set_sensor_frame_rate(float value) {
  _internal_set_sensor_frame_rate(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.sensor_frame_rate)
}
inline float Header_ClipMetadata::_internal_sensor_frame_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_frame_rate_;
}
inline void Header_ClipMetadata::_internal_set_sensor_frame_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sensor_frame_rate_ = value;
}

// float file_frame_rate = 6;
inline void Header_ClipMetadata::clear_file_frame_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_frame_rate_ = 0;
}
inline float Header_ClipMetadata::file_frame_rate() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.file_frame_rate)
  return _internal_file_frame_rate();
}
inline void Header_ClipMetadata::set_file_frame_rate(float value) {
  _internal_set_file_frame_rate(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.file_frame_rate)
}
inline float Header_ClipMetadata::_internal_file_frame_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_frame_rate_;
}
inline void Header_ClipMetadata::_internal_set_file_frame_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.file_frame_rate_ = value;
}

// int32 rotation_degrees = 7;
inline void Header_ClipMetadata::clear_rotation_degrees() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotation_degrees_ = 0;
}
inline ::int32_t Header_ClipMetadata::rotation_degrees() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.rotation_degrees)
  return _internal_rotation_degrees();
}
inline void Header_ClipMetadata::set_rotation_degrees(::int32_t value) {
  _internal_set_rotation_degrees(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.rotation_degrees)
}
inline ::int32_t Header_ClipMetadata::_internal_rotation_degrees() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotation_degrees_;
}
inline void Header_ClipMetadata::_internal_set_rotation_degrees(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rotation_degrees_ = value;
}

// uint32 imu_sample_rate = 8;
inline void Header_ClipMetadata::clear_imu_sample_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imu_sample_rate_ = 0u;
}
inline ::uint32_t Header_ClipMetadata::imu_sample_rate() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.imu_sample_rate)
  return _internal_imu_sample_rate();
}
inline void Header_ClipMetadata::set_imu_sample_rate(::uint32_t value) {
  _internal_set_imu_sample_rate(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.imu_sample_rate)
}
inline ::uint32_t Header_ClipMetadata::_internal_imu_sample_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imu_sample_rate_;
}
inline void Header_ClipMetadata::_internal_set_imu_sample_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.imu_sample_rate_ = value;
}

// optional string color_profile = 9;
inline bool Header_ClipMetadata::has_color_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Header_ClipMetadata::clear_color_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_profile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header_ClipMetadata::color_profile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.color_profile)
  return _internal_color_profile();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header_ClipMetadata::set_color_profile(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.color_profile_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.color_profile)
}
inline std::string* Header_ClipMetadata::mutable_color_profile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color_profile();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.ClipMetadata.color_profile)
  return _s;
}
inline const std::string& Header_ClipMetadata::_internal_color_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_profile_.Get();
}
inline void Header_ClipMetadata::_internal_set_color_profile(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.color_profile_.Set(value, GetArena());
}
inline std::string* Header_ClipMetadata::_internal_mutable_color_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.color_profile_.Mutable( GetArena());
}
inline std::string* Header_ClipMetadata::release_color_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.ClipMetadata.color_profile)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.color_profile_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.color_profile_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Header_ClipMetadata::set_allocated_color_profile(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_profile_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_profile_.IsDefault()) {
          _impl_.color_profile_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.ClipMetadata.color_profile)
}

// float pixel_aspect_ratio = 10;
inline void Header_ClipMetadata::clear_pixel_aspect_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pixel_aspect_ratio_ = 0;
}
inline float Header_ClipMetadata::pixel_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.pixel_aspect_ratio)
  return _internal_pixel_aspect_ratio();
}
inline void Header_ClipMetadata::set_pixel_aspect_ratio(float value) {
  _internal_set_pixel_aspect_ratio(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.pixel_aspect_ratio)
}
inline float Header_ClipMetadata::_internal_pixel_aspect_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pixel_aspect_ratio_;
}
inline void Header_ClipMetadata::_internal_set_pixel_aspect_ratio(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pixel_aspect_ratio_ = value;
}

// float frame_readout_time_us = 11;
inline void Header_ClipMetadata::clear_frame_readout_time_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_readout_time_us_ = 0;
}
inline float Header_ClipMetadata::frame_readout_time_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.frame_readout_time_us)
  return _internal_frame_readout_time_us();
}
inline void Header_ClipMetadata::set_frame_readout_time_us(float value) {
  _internal_set_frame_readout_time_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.frame_readout_time_us)
}
inline float Header_ClipMetadata::_internal_frame_readout_time_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_readout_time_us_;
}
inline void Header_ClipMetadata::_internal_set_frame_readout_time_us(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_readout_time_us_ = value;
}

// .gyroflow.Header.ClipMetadata.ReadoutDirection frame_readout_direction = 12;
inline void Header_ClipMetadata::clear_frame_readout_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_readout_direction_ = 0;
}
inline ::gyroflow::Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::frame_readout_direction() const {
  // @@protoc_insertion_point(field_get:gyroflow.Header.ClipMetadata.frame_readout_direction)
  return _internal_frame_readout_direction();
}
inline void Header_ClipMetadata::set_frame_readout_direction(::gyroflow::Header_ClipMetadata_ReadoutDirection value) {
  _internal_set_frame_readout_direction(value);
  // @@protoc_insertion_point(field_set:gyroflow.Header.ClipMetadata.frame_readout_direction)
}
inline ::gyroflow::Header_ClipMetadata_ReadoutDirection Header_ClipMetadata::_internal_frame_readout_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gyroflow::Header_ClipMetadata_ReadoutDirection>(_impl_.frame_readout_direction_);
}
inline void Header_ClipMetadata::_internal_set_frame_readout_direction(::gyroflow::Header_ClipMetadata_ReadoutDirection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_readout_direction_ = value;
}

// -------------------------------------------------------------------

// Header

// .gyroflow.Header.CameraMetadata camera = 1;
inline bool Header::has_camera() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_ != nullptr);
  return value;
}
inline void Header::clear_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.camera_ != nullptr) _impl_.camera_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gyroflow::Header_CameraMetadata& Header::_internal_camera() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Header_CameraMetadata* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Header_CameraMetadata&>(::gyroflow::_Header_CameraMetadata_default_instance_);
}
inline const ::gyroflow::Header_CameraMetadata& Header::camera() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.camera)
  return _internal_camera();
}
inline void Header::unsafe_arena_set_allocated_camera(::gyroflow::Header_CameraMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = reinterpret_cast<::gyroflow::Header_CameraMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Header.camera)
}
inline ::gyroflow::Header_CameraMetadata* Header::release_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Header_CameraMetadata* released = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Header_CameraMetadata* Header::unsafe_arena_release_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.camera)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Header_CameraMetadata* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::gyroflow::Header_CameraMetadata* Header::_internal_mutable_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Header_CameraMetadata>(GetArena());
    _impl_.camera_ = reinterpret_cast<::gyroflow::Header_CameraMetadata*>(p);
  }
  return _impl_.camera_;
}
inline ::gyroflow::Header_CameraMetadata* Header::mutable_camera() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Header_CameraMetadata* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.camera)
  return _msg;
}
inline void Header::set_allocated_camera(::gyroflow::Header_CameraMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Header_CameraMetadata*>(_impl_.camera_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Header_CameraMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.camera_ = reinterpret_cast<::gyroflow::Header_CameraMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.camera)
}

// .gyroflow.Header.ClipMetadata clip = 2;
inline bool Header::has_clip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.clip_ != nullptr);
  return value;
}
inline void Header::clear_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.clip_ != nullptr) _impl_.clip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gyroflow::Header_ClipMetadata& Header::_internal_clip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Header_ClipMetadata* p = _impl_.clip_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Header_ClipMetadata&>(::gyroflow::_Header_ClipMetadata_default_instance_);
}
inline const ::gyroflow::Header_ClipMetadata& Header::clip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.Header.clip)
  return _internal_clip();
}
inline void Header::unsafe_arena_set_allocated_clip(::gyroflow::Header_ClipMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.clip_);
  }
  _impl_.clip_ = reinterpret_cast<::gyroflow::Header_ClipMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.Header.clip)
}
inline ::gyroflow::Header_ClipMetadata* Header::release_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::Header_ClipMetadata* released = _impl_.clip_;
  _impl_.clip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Header_ClipMetadata* Header::unsafe_arena_release_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.Header.clip)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::Header_ClipMetadata* temp = _impl_.clip_;
  _impl_.clip_ = nullptr;
  return temp;
}
inline ::gyroflow::Header_ClipMetadata* Header::_internal_mutable_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.clip_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Header_ClipMetadata>(GetArena());
    _impl_.clip_ = reinterpret_cast<::gyroflow::Header_ClipMetadata*>(p);
  }
  return _impl_.clip_;
}
inline ::gyroflow::Header_ClipMetadata* Header::mutable_clip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Header_ClipMetadata* _msg = _internal_mutable_clip();
  // @@protoc_insertion_point(field_mutable:gyroflow.Header.clip)
  return _msg;
}
inline void Header::set_allocated_clip(::gyroflow::Header_ClipMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Header_ClipMetadata*>(_impl_.clip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Header_ClipMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.clip_ = reinterpret_cast<::gyroflow::Header_ClipMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.Header.clip)
}

// -------------------------------------------------------------------

// FrameMetadata

// double start_timestamp_us = 1;
inline void FrameMetadata::clear_start_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_timestamp_us_ = 0;
}
inline double FrameMetadata::start_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.start_timestamp_us)
  return _internal_start_timestamp_us();
}
inline void FrameMetadata::set_start_timestamp_us(double value) {
  _internal_set_start_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.start_timestamp_us)
}
inline double FrameMetadata::_internal_start_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_timestamp_us_;
}
inline void FrameMetadata::_internal_set_start_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_timestamp_us_ = value;
}

// double end_timestamp_us = 2;
inline void FrameMetadata::clear_end_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_timestamp_us_ = 0;
}
inline double FrameMetadata::end_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.end_timestamp_us)
  return _internal_end_timestamp_us();
}
inline void FrameMetadata::set_end_timestamp_us(double value) {
  _internal_set_end_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.end_timestamp_us)
}
inline double FrameMetadata::_internal_end_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_timestamp_us_;
}
inline void FrameMetadata::_internal_set_end_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_timestamp_us_ = value;
}

// uint32 frame_number = 3;
inline void FrameMetadata::clear_frame_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_number_ = 0u;
}
inline ::uint32_t FrameMetadata::frame_number() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.frame_number)
  return _internal_frame_number();
}
inline void FrameMetadata::set_frame_number(::uint32_t value) {
  _internal_set_frame_number(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.frame_number)
}
inline ::uint32_t FrameMetadata::_internal_frame_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_number_;
}
inline void FrameMetadata::_internal_set_frame_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_number_ = value;
}

// optional uint32 iso = 4;
inline bool FrameMetadata::has_iso() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameMetadata::clear_iso() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.iso_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t FrameMetadata::iso() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.iso)
  return _internal_iso();
}
inline void FrameMetadata::set_iso(::uint32_t value) {
  _internal_set_iso(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.iso)
}
inline ::uint32_t FrameMetadata::_internal_iso() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.iso_;
}
inline void FrameMetadata::_internal_set_iso(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iso_ = value;
}

// optional float exposure_time_us = 5;
inline bool FrameMetadata::has_exposure_time_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameMetadata::clear_exposure_time_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exposure_time_us_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FrameMetadata::exposure_time_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.exposure_time_us)
  return _internal_exposure_time_us();
}
inline void FrameMetadata::set_exposure_time_us(float value) {
  _internal_set_exposure_time_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.exposure_time_us)
}
inline float FrameMetadata::_internal_exposure_time_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exposure_time_us_;
}
inline void FrameMetadata::_internal_set_exposure_time_us(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.exposure_time_us_ = value;
}

// optional uint32 white_balance_kelvin = 6;
inline bool FrameMetadata::has_white_balance_kelvin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FrameMetadata::clear_white_balance_kelvin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.white_balance_kelvin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t FrameMetadata::white_balance_kelvin() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.white_balance_kelvin)
  return _internal_white_balance_kelvin();
}
inline void FrameMetadata::set_white_balance_kelvin(::uint32_t value) {
  _internal_set_white_balance_kelvin(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.white_balance_kelvin)
}
inline ::uint32_t FrameMetadata::_internal_white_balance_kelvin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.white_balance_kelvin_;
}
inline void FrameMetadata::_internal_set_white_balance_kelvin(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.white_balance_kelvin_ = value;
}

// optional float white_balance_tint = 7;
inline bool FrameMetadata::has_white_balance_tint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FrameMetadata::clear_white_balance_tint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.white_balance_tint_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FrameMetadata::white_balance_tint() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.white_balance_tint)
  return _internal_white_balance_tint();
}
inline void FrameMetadata::set_white_balance_tint(float value) {
  _internal_set_white_balance_tint(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.white_balance_tint)
}
inline float FrameMetadata::_internal_white_balance_tint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.white_balance_tint_;
}
inline void FrameMetadata::_internal_set_white_balance_tint(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.white_balance_tint_ = value;
}

// optional float digital_zoom_ratio = 8;
inline bool FrameMetadata::has_digital_zoom_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FrameMetadata::clear_digital_zoom_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digital_zoom_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float FrameMetadata::digital_zoom_ratio() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.digital_zoom_ratio)
  return _internal_digital_zoom_ratio();
}
inline void FrameMetadata::set_digital_zoom_ratio(float value) {
  _internal_set_digital_zoom_ratio(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.digital_zoom_ratio)
}
inline float FrameMetadata::_internal_digital_zoom_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digital_zoom_ratio_;
}
inline void FrameMetadata::_internal_set_digital_zoom_ratio(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.digital_zoom_ratio_ = value;
}

// optional int32 shutter_speed_numerator = 9;
inline bool FrameMetadata::has_shutter_speed_numerator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FrameMetadata::clear_shutter_speed_numerator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shutter_speed_numerator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t FrameMetadata::shutter_speed_numerator() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.shutter_speed_numerator)
  return _internal_shutter_speed_numerator();
}
inline void FrameMetadata::set_shutter_speed_numerator(::int32_t value) {
  _internal_set_shutter_speed_numerator(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.shutter_speed_numerator)
}
inline ::int32_t FrameMetadata::_internal_shutter_speed_numerator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shutter_speed_numerator_;
}
inline void FrameMetadata::_internal_set_shutter_speed_numerator(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.shutter_speed_numerator_ = value;
}

// optional int32 shutter_speed_denumerator = 10;
inline bool FrameMetadata::has_shutter_speed_denumerator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FrameMetadata::clear_shutter_speed_denumerator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shutter_speed_denumerator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t FrameMetadata::shutter_speed_denumerator() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.shutter_speed_denumerator)
  return _internal_shutter_speed_denumerator();
}
inline void FrameMetadata::set_shutter_speed_denumerator(::int32_t value) {
  _internal_set_shutter_speed_denumerator(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.shutter_speed_denumerator)
}
inline ::int32_t FrameMetadata::_internal_shutter_speed_denumerator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shutter_speed_denumerator_;
}
inline void FrameMetadata::_internal_set_shutter_speed_denumerator(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shutter_speed_denumerator_ = value;
}

// optional float shutter_angle_degrees = 11;
inline bool FrameMetadata::has_shutter_angle_degrees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FrameMetadata::clear_shutter_angle_degrees() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shutter_angle_degrees_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float FrameMetadata::shutter_angle_degrees() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.shutter_angle_degrees)
  return _internal_shutter_angle_degrees();
}
inline void FrameMetadata::set_shutter_angle_degrees(float value) {
  _internal_set_shutter_angle_degrees(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.shutter_angle_degrees)
}
inline float FrameMetadata::_internal_shutter_angle_degrees() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shutter_angle_degrees_;
}
inline void FrameMetadata::_internal_set_shutter_angle_degrees(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.shutter_angle_degrees_ = value;
}

// optional float crop_x = 12;
inline bool FrameMetadata::has_crop_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void FrameMetadata::clear_crop_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crop_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float FrameMetadata::crop_x() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.crop_x)
  return _internal_crop_x();
}
inline void FrameMetadata::set_crop_x(float value) {
  _internal_set_crop_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.crop_x)
}
inline float FrameMetadata::_internal_crop_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crop_x_;
}
inline void FrameMetadata::_internal_set_crop_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.crop_x_ = value;
}

// optional float crop_y = 13;
inline bool FrameMetadata::has_crop_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void FrameMetadata::clear_crop_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crop_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float FrameMetadata::crop_y() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.crop_y)
  return _internal_crop_y();
}
inline void FrameMetadata::set_crop_y(float value) {
  _internal_set_crop_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.crop_y)
}
inline float FrameMetadata::_internal_crop_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crop_y_;
}
inline void FrameMetadata::_internal_set_crop_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.crop_y_ = value;
}

// optional float crop_width = 14;
inline bool FrameMetadata::has_crop_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void FrameMetadata::clear_crop_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crop_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float FrameMetadata::crop_width() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.crop_width)
  return _internal_crop_width();
}
inline void FrameMetadata::set_crop_width(float value) {
  _internal_set_crop_width(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.crop_width)
}
inline float FrameMetadata::_internal_crop_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crop_width_;
}
inline void FrameMetadata::_internal_set_crop_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.crop_width_ = value;
}

// optional float crop_height = 15;
inline bool FrameMetadata::has_crop_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void FrameMetadata::clear_crop_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crop_height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float FrameMetadata::crop_height() const {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.crop_height)
  return _internal_crop_height();
}
inline void FrameMetadata::set_crop_height(float value) {
  _internal_set_crop_height(value);
  // @@protoc_insertion_point(field_set:gyroflow.FrameMetadata.crop_height)
}
inline float FrameMetadata::_internal_crop_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crop_height_;
}
inline void FrameMetadata::_internal_set_crop_height(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.crop_height_ = value;
}

// repeated .gyroflow.LensData lens = 16;
inline int FrameMetadata::_internal_lens_size() const {
  return _internal_lens().size();
}
inline int FrameMetadata::lens_size() const {
  return _internal_lens_size();
}
inline void FrameMetadata::clear_lens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lens_.Clear();
}
inline ::gyroflow::LensData* FrameMetadata::mutable_lens(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.lens)
  return _internal_mutable_lens()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>* FrameMetadata::mutable_lens()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.lens)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lens();
}
inline const ::gyroflow::LensData& FrameMetadata::lens(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.lens)
  return _internal_lens().Get(index);
}
inline ::gyroflow::LensData* FrameMetadata::add_lens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::LensData* _add = _internal_mutable_lens()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.lens)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>& FrameMetadata::lens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.lens)
  return _internal_lens();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>&
FrameMetadata::_internal_lens() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lens_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::LensData>*
FrameMetadata::_internal_mutable_lens() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lens_;
}

// repeated .gyroflow.IMUData imu = 17;
inline int FrameMetadata::_internal_imu_size() const {
  return _internal_imu().size();
}
inline int FrameMetadata::imu_size() const {
  return _internal_imu_size();
}
inline void FrameMetadata::clear_imu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imu_.Clear();
}
inline ::gyroflow::IMUData* FrameMetadata::mutable_imu(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.imu)
  return _internal_mutable_imu()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>* FrameMetadata::mutable_imu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.imu)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_imu();
}
inline const ::gyroflow::IMUData& FrameMetadata::imu(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.imu)
  return _internal_imu().Get(index);
}
inline ::gyroflow::IMUData* FrameMetadata::add_imu() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::IMUData* _add = _internal_mutable_imu()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.imu)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>& FrameMetadata::imu() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.imu)
  return _internal_imu();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>&
FrameMetadata::_internal_imu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imu_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::IMUData>*
FrameMetadata::_internal_mutable_imu() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.imu_;
}

// repeated .gyroflow.QuaternionData quaternions = 18;
inline int FrameMetadata::_internal_quaternions_size() const {
  return _internal_quaternions().size();
}
inline int FrameMetadata::quaternions_size() const {
  return _internal_quaternions_size();
}
inline void FrameMetadata::clear_quaternions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quaternions_.Clear();
}
inline ::gyroflow::QuaternionData* FrameMetadata::mutable_quaternions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.quaternions)
  return _internal_mutable_quaternions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>* FrameMetadata::mutable_quaternions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.quaternions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_quaternions();
}
inline const ::gyroflow::QuaternionData& FrameMetadata::quaternions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.quaternions)
  return _internal_quaternions().Get(index);
}
inline ::gyroflow::QuaternionData* FrameMetadata::add_quaternions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::QuaternionData* _add = _internal_mutable_quaternions()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.quaternions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>& FrameMetadata::quaternions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.quaternions)
  return _internal_quaternions();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>&
FrameMetadata::_internal_quaternions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quaternions_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::QuaternionData>*
FrameMetadata::_internal_mutable_quaternions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.quaternions_;
}

// repeated .gyroflow.LensOISData ois = 19;
inline int FrameMetadata::_internal_ois_size() const {
  return _internal_ois().size();
}
inline int FrameMetadata::ois_size() const {
  return _internal_ois_size();
}
inline void FrameMetadata::clear_ois() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ois_.Clear();
}
inline ::gyroflow::LensOISData* FrameMetadata::mutable_ois(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.ois)
  return _internal_mutable_ois()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>* FrameMetadata::mutable_ois()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.ois)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ois();
}
inline const ::gyroflow::LensOISData& FrameMetadata::ois(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.ois)
  return _internal_ois().Get(index);
}
inline ::gyroflow::LensOISData* FrameMetadata::add_ois() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::LensOISData* _add = _internal_mutable_ois()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.ois)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>& FrameMetadata::ois() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.ois)
  return _internal_ois();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>&
FrameMetadata::_internal_ois() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ois_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::LensOISData>*
FrameMetadata::_internal_mutable_ois() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ois_;
}

// repeated .gyroflow.IBISData ibis = 20;
inline int FrameMetadata::_internal_ibis_size() const {
  return _internal_ibis().size();
}
inline int FrameMetadata::ibis_size() const {
  return _internal_ibis_size();
}
inline void FrameMetadata::clear_ibis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ibis_.Clear();
}
inline ::gyroflow::IBISData* FrameMetadata::mutable_ibis(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.ibis)
  return _internal_mutable_ibis()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>* FrameMetadata::mutable_ibis()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.ibis)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ibis();
}
inline const ::gyroflow::IBISData& FrameMetadata::ibis(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.ibis)
  return _internal_ibis().Get(index);
}
inline ::gyroflow::IBISData* FrameMetadata::add_ibis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::IBISData* _add = _internal_mutable_ibis()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.ibis)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>& FrameMetadata::ibis() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.ibis)
  return _internal_ibis();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>&
FrameMetadata::_internal_ibis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ibis_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::IBISData>*
FrameMetadata::_internal_mutable_ibis() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ibis_;
}

// repeated .gyroflow.EISData eis = 21;
inline int FrameMetadata::_internal_eis_size() const {
  return _internal_eis().size();
}
inline int FrameMetadata::eis_size() const {
  return _internal_eis_size();
}
inline void FrameMetadata::clear_eis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eis_.Clear();
}
inline ::gyroflow::EISData* FrameMetadata::mutable_eis(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gyroflow.FrameMetadata.eis)
  return _internal_mutable_eis()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>* FrameMetadata::mutable_eis()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.FrameMetadata.eis)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_eis();
}
inline const ::gyroflow::EISData& FrameMetadata::eis(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.FrameMetadata.eis)
  return _internal_eis().Get(index);
}
inline ::gyroflow::EISData* FrameMetadata::add_eis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::gyroflow::EISData* _add = _internal_mutable_eis()->Add();
  // @@protoc_insertion_point(field_add:gyroflow.FrameMetadata.eis)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>& FrameMetadata::eis() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.FrameMetadata.eis)
  return _internal_eis();
}
inline const ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>&
FrameMetadata::_internal_eis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.eis_;
}
inline ::google::protobuf::RepeatedPtrField<::gyroflow::EISData>*
FrameMetadata::_internal_mutable_eis() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.eis_;
}

// -------------------------------------------------------------------

// LensData

// .gyroflow.LensData.DistortionModel distortion_model = 1;
inline void LensData::clear_distortion_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distortion_model_ = 0;
}
inline ::gyroflow::LensData_DistortionModel LensData::distortion_model() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.distortion_model)
  return _internal_distortion_model();
}
inline void LensData::set_distortion_model(::gyroflow::LensData_DistortionModel value) {
  _internal_set_distortion_model(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.distortion_model)
}
inline ::gyroflow::LensData_DistortionModel LensData::_internal_distortion_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gyroflow::LensData_DistortionModel>(_impl_.distortion_model_);
}
inline void LensData::_internal_set_distortion_model(::gyroflow::LensData_DistortionModel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distortion_model_ = value;
}

// repeated float distortion_coefficients = 2;
inline int LensData::_internal_distortion_coefficients_size() const {
  return _internal_distortion_coefficients().size();
}
inline int LensData::distortion_coefficients_size() const {
  return _internal_distortion_coefficients_size();
}
inline void LensData::clear_distortion_coefficients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distortion_coefficients_.Clear();
}
inline float LensData::distortion_coefficients(int index) const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.distortion_coefficients)
  return _internal_distortion_coefficients().Get(index);
}
inline void LensData::set_distortion_coefficients(int index, float value) {
  _internal_mutable_distortion_coefficients()->Set(index, value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.distortion_coefficients)
}
inline void LensData::add_distortion_coefficients(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_distortion_coefficients()->Add(value);
  // @@protoc_insertion_point(field_add:gyroflow.LensData.distortion_coefficients)
}
inline const ::google::protobuf::RepeatedField<float>& LensData::distortion_coefficients() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.LensData.distortion_coefficients)
  return _internal_distortion_coefficients();
}
inline ::google::protobuf::RepeatedField<float>* LensData::mutable_distortion_coefficients()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.LensData.distortion_coefficients)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_distortion_coefficients();
}
inline const ::google::protobuf::RepeatedField<float>& LensData::_internal_distortion_coefficients()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distortion_coefficients_;
}
inline ::google::protobuf::RepeatedField<float>* LensData::_internal_mutable_distortion_coefficients() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.distortion_coefficients_;
}

// repeated float camera_intrinsic_matrix = 3;
inline int LensData::_internal_camera_intrinsic_matrix_size() const {
  return _internal_camera_intrinsic_matrix().size();
}
inline int LensData::camera_intrinsic_matrix_size() const {
  return _internal_camera_intrinsic_matrix_size();
}
inline void LensData::clear_camera_intrinsic_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camera_intrinsic_matrix_.Clear();
}
inline float LensData::camera_intrinsic_matrix(int index) const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.camera_intrinsic_matrix)
  return _internal_camera_intrinsic_matrix().Get(index);
}
inline void LensData::set_camera_intrinsic_matrix(int index, float value) {
  _internal_mutable_camera_intrinsic_matrix()->Set(index, value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.camera_intrinsic_matrix)
}
inline void LensData::add_camera_intrinsic_matrix(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_camera_intrinsic_matrix()->Add(value);
  // @@protoc_insertion_point(field_add:gyroflow.LensData.camera_intrinsic_matrix)
}
inline const ::google::protobuf::RepeatedField<float>& LensData::camera_intrinsic_matrix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.LensData.camera_intrinsic_matrix)
  return _internal_camera_intrinsic_matrix();
}
inline ::google::protobuf::RepeatedField<float>* LensData::mutable_camera_intrinsic_matrix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.LensData.camera_intrinsic_matrix)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_camera_intrinsic_matrix();
}
inline const ::google::protobuf::RepeatedField<float>& LensData::_internal_camera_intrinsic_matrix()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camera_intrinsic_matrix_;
}
inline ::google::protobuf::RepeatedField<float>* LensData::_internal_mutable_camera_intrinsic_matrix() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.camera_intrinsic_matrix_;
}

// optional float focal_length_mm = 4;
inline bool LensData::has_focal_length_mm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LensData::clear_focal_length_mm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focal_length_mm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float LensData::focal_length_mm() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.focal_length_mm)
  return _internal_focal_length_mm();
}
inline void LensData::set_focal_length_mm(float value) {
  _internal_set_focal_length_mm(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.focal_length_mm)
}
inline float LensData::_internal_focal_length_mm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.focal_length_mm_;
}
inline void LensData::_internal_set_focal_length_mm(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focal_length_mm_ = value;
}

// optional float f_number = 5;
inline bool LensData::has_f_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LensData::clear_f_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float LensData::f_number() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.f_number)
  return _internal_f_number();
}
inline void LensData::set_f_number(float value) {
  _internal_set_f_number(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.f_number)
}
inline float LensData::_internal_f_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.f_number_;
}
inline void LensData::_internal_set_f_number(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.f_number_ = value;
}

// optional float focus_distance_mm = 6;
inline bool LensData::has_focus_distance_mm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LensData::clear_focus_distance_mm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focus_distance_mm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float LensData::focus_distance_mm() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensData.focus_distance_mm)
  return _internal_focus_distance_mm();
}
inline void LensData::set_focus_distance_mm(float value) {
  _internal_set_focus_distance_mm(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensData.focus_distance_mm)
}
inline float LensData::_internal_focus_distance_mm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.focus_distance_mm_;
}
inline void LensData::_internal_set_focus_distance_mm(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.focus_distance_mm_ = value;
}

// -------------------------------------------------------------------

// IMUData

// double sample_timestamp_us = 1;
inline void IMUData::clear_sample_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_timestamp_us_ = 0;
}
inline double IMUData::sample_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.sample_timestamp_us)
  return _internal_sample_timestamp_us();
}
inline void IMUData::set_sample_timestamp_us(double value) {
  _internal_set_sample_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.sample_timestamp_us)
}
inline double IMUData::_internal_sample_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_timestamp_us_;
}
inline void IMUData::_internal_set_sample_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_timestamp_us_ = value;
}

// float gyroscope_x = 2;
inline void IMUData::clear_gyroscope_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gyroscope_x_ = 0;
}
inline float IMUData::gyroscope_x() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.gyroscope_x)
  return _internal_gyroscope_x();
}
inline void IMUData::set_gyroscope_x(float value) {
  _internal_set_gyroscope_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.gyroscope_x)
}
inline float IMUData::_internal_gyroscope_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gyroscope_x_;
}
inline void IMUData::_internal_set_gyroscope_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gyroscope_x_ = value;
}

// float gyroscope_y = 3;
inline void IMUData::clear_gyroscope_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gyroscope_y_ = 0;
}
inline float IMUData::gyroscope_y() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.gyroscope_y)
  return _internal_gyroscope_y();
}
inline void IMUData::set_gyroscope_y(float value) {
  _internal_set_gyroscope_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.gyroscope_y)
}
inline float IMUData::_internal_gyroscope_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gyroscope_y_;
}
inline void IMUData::_internal_set_gyroscope_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gyroscope_y_ = value;
}

// float gyroscope_z = 4;
inline void IMUData::clear_gyroscope_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gyroscope_z_ = 0;
}
inline float IMUData::gyroscope_z() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.gyroscope_z)
  return _internal_gyroscope_z();
}
inline void IMUData::set_gyroscope_z(float value) {
  _internal_set_gyroscope_z(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.gyroscope_z)
}
inline float IMUData::_internal_gyroscope_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gyroscope_z_;
}
inline void IMUData::_internal_set_gyroscope_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gyroscope_z_ = value;
}

// float accelerometer_x = 5;
inline void IMUData::clear_accelerometer_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accelerometer_x_ = 0;
}
inline float IMUData::accelerometer_x() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.accelerometer_x)
  return _internal_accelerometer_x();
}
inline void IMUData::set_accelerometer_x(float value) {
  _internal_set_accelerometer_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.accelerometer_x)
}
inline float IMUData::_internal_accelerometer_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accelerometer_x_;
}
inline void IMUData::_internal_set_accelerometer_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accelerometer_x_ = value;
}

// float accelerometer_y = 6;
inline void IMUData::clear_accelerometer_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accelerometer_y_ = 0;
}
inline float IMUData::accelerometer_y() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.accelerometer_y)
  return _internal_accelerometer_y();
}
inline void IMUData::set_accelerometer_y(float value) {
  _internal_set_accelerometer_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.accelerometer_y)
}
inline float IMUData::_internal_accelerometer_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accelerometer_y_;
}
inline void IMUData::_internal_set_accelerometer_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accelerometer_y_ = value;
}

// float accelerometer_z = 7;
inline void IMUData::clear_accelerometer_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accelerometer_z_ = 0;
}
inline float IMUData::accelerometer_z() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.accelerometer_z)
  return _internal_accelerometer_z();
}
inline void IMUData::set_accelerometer_z(float value) {
  _internal_set_accelerometer_z(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.accelerometer_z)
}
inline float IMUData::_internal_accelerometer_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accelerometer_z_;
}
inline void IMUData::_internal_set_accelerometer_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accelerometer_z_ = value;
}

// optional float magnetometer_x = 8;
inline bool IMUData::has_magnetometer_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IMUData::clear_magnetometer_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magnetometer_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float IMUData::magnetometer_x() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.magnetometer_x)
  return _internal_magnetometer_x();
}
inline void IMUData::set_magnetometer_x(float value) {
  _internal_set_magnetometer_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.magnetometer_x)
}
inline float IMUData::_internal_magnetometer_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.magnetometer_x_;
}
inline void IMUData::_internal_set_magnetometer_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.magnetometer_x_ = value;
}

// optional float magnetometer_y = 9;
inline bool IMUData::has_magnetometer_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IMUData::clear_magnetometer_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magnetometer_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float IMUData::magnetometer_y() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.magnetometer_y)
  return _internal_magnetometer_y();
}
inline void IMUData::set_magnetometer_y(float value) {
  _internal_set_magnetometer_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.magnetometer_y)
}
inline float IMUData::_internal_magnetometer_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.magnetometer_y_;
}
inline void IMUData::_internal_set_magnetometer_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.magnetometer_y_ = value;
}

// optional float magnetometer_z = 10;
inline bool IMUData::has_magnetometer_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IMUData::clear_magnetometer_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magnetometer_z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float IMUData::magnetometer_z() const {
  // @@protoc_insertion_point(field_get:gyroflow.IMUData.magnetometer_z)
  return _internal_magnetometer_z();
}
inline void IMUData::set_magnetometer_z(float value) {
  _internal_set_magnetometer_z(value);
  // @@protoc_insertion_point(field_set:gyroflow.IMUData.magnetometer_z)
}
inline float IMUData::_internal_magnetometer_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.magnetometer_z_;
}
inline void IMUData::_internal_set_magnetometer_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.magnetometer_z_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// float w = 1;
inline void Quaternion::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.w_ = 0;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:gyroflow.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:gyroflow.Quaternion.w)
}
inline float Quaternion::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.w_;
}
inline void Quaternion::_internal_set_w(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.w_ = value;
}

// float x = 2;
inline void Quaternion::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:gyroflow.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.Quaternion.x)
}
inline float Quaternion::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Quaternion::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 3;
inline void Quaternion::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:gyroflow.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.Quaternion.y)
}
inline float Quaternion::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Quaternion::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float z = 4;
inline void Quaternion::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:gyroflow.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:gyroflow.Quaternion.z)
}
inline float Quaternion::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Quaternion::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// QuaternionData

// double sample_timestamp_us = 1;
inline void QuaternionData::clear_sample_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_timestamp_us_ = 0;
}
inline double QuaternionData::sample_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.QuaternionData.sample_timestamp_us)
  return _internal_sample_timestamp_us();
}
inline void QuaternionData::set_sample_timestamp_us(double value) {
  _internal_set_sample_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.QuaternionData.sample_timestamp_us)
}
inline double QuaternionData::_internal_sample_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_timestamp_us_;
}
inline void QuaternionData::_internal_set_sample_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_timestamp_us_ = value;
}

// .gyroflow.Quaternion quat = 2;
inline bool QuaternionData::has_quat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quat_ != nullptr);
  return value;
}
inline void QuaternionData::clear_quat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.quat_ != nullptr) _impl_.quat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gyroflow::Quaternion& QuaternionData::_internal_quat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Quaternion* p = _impl_.quat_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Quaternion&>(::gyroflow::_Quaternion_default_instance_);
}
inline const ::gyroflow::Quaternion& QuaternionData::quat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.QuaternionData.quat)
  return _internal_quat();
}
inline void QuaternionData::unsafe_arena_set_allocated_quat(::gyroflow::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quat_);
  }
  _impl_.quat_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.QuaternionData.quat)
}
inline ::gyroflow::Quaternion* QuaternionData::release_quat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Quaternion* released = _impl_.quat_;
  _impl_.quat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Quaternion* QuaternionData::unsafe_arena_release_quat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.QuaternionData.quat)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Quaternion* temp = _impl_.quat_;
  _impl_.quat_ = nullptr;
  return temp;
}
inline ::gyroflow::Quaternion* QuaternionData::_internal_mutable_quat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.quat_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Quaternion>(GetArena());
    _impl_.quat_ = reinterpret_cast<::gyroflow::Quaternion*>(p);
  }
  return _impl_.quat_;
}
inline ::gyroflow::Quaternion* QuaternionData::mutable_quat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Quaternion* _msg = _internal_mutable_quat();
  // @@protoc_insertion_point(field_mutable:gyroflow.QuaternionData.quat)
  return _msg;
}
inline void QuaternionData::set_allocated_quat(::gyroflow::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Quaternion*>(_impl_.quat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.quat_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.QuaternionData.quat)
}

// -------------------------------------------------------------------

// LensOISData

// double sample_timestamp_us = 1;
inline void LensOISData::clear_sample_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_timestamp_us_ = 0;
}
inline double LensOISData::sample_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensOISData.sample_timestamp_us)
  return _internal_sample_timestamp_us();
}
inline void LensOISData::set_sample_timestamp_us(double value) {
  _internal_set_sample_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensOISData.sample_timestamp_us)
}
inline double LensOISData::_internal_sample_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_timestamp_us_;
}
inline void LensOISData::_internal_set_sample_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_timestamp_us_ = value;
}

// float x = 2;
inline void LensOISData::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float LensOISData::x() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensOISData.x)
  return _internal_x();
}
inline void LensOISData::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensOISData.x)
}
inline float LensOISData::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void LensOISData::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 3;
inline void LensOISData::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float LensOISData::y() const {
  // @@protoc_insertion_point(field_get:gyroflow.LensOISData.y)
  return _internal_y();
}
inline void LensOISData::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.LensOISData.y)
}
inline float LensOISData::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void LensOISData::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// IBISData

// double sample_timestamp_us = 1;
inline void IBISData::clear_sample_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_timestamp_us_ = 0;
}
inline double IBISData::sample_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.IBISData.sample_timestamp_us)
  return _internal_sample_timestamp_us();
}
inline void IBISData::set_sample_timestamp_us(double value) {
  _internal_set_sample_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.IBISData.sample_timestamp_us)
}
inline double IBISData::_internal_sample_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_timestamp_us_;
}
inline void IBISData::_internal_set_sample_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_timestamp_us_ = value;
}

// float shift_x = 2;
inline void IBISData::clear_shift_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shift_x_ = 0;
}
inline float IBISData::shift_x() const {
  // @@protoc_insertion_point(field_get:gyroflow.IBISData.shift_x)
  return _internal_shift_x();
}
inline void IBISData::set_shift_x(float value) {
  _internal_set_shift_x(value);
  // @@protoc_insertion_point(field_set:gyroflow.IBISData.shift_x)
}
inline float IBISData::_internal_shift_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shift_x_;
}
inline void IBISData::_internal_set_shift_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shift_x_ = value;
}

// float shift_y = 3;
inline void IBISData::clear_shift_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shift_y_ = 0;
}
inline float IBISData::shift_y() const {
  // @@protoc_insertion_point(field_get:gyroflow.IBISData.shift_y)
  return _internal_shift_y();
}
inline void IBISData::set_shift_y(float value) {
  _internal_set_shift_y(value);
  // @@protoc_insertion_point(field_set:gyroflow.IBISData.shift_y)
}
inline float IBISData::_internal_shift_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shift_y_;
}
inline void IBISData::_internal_set_shift_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shift_y_ = value;
}

// float roll_angle_degrees = 4;
inline void IBISData::clear_roll_angle_degrees() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roll_angle_degrees_ = 0;
}
inline float IBISData::roll_angle_degrees() const {
  // @@protoc_insertion_point(field_get:gyroflow.IBISData.roll_angle_degrees)
  return _internal_roll_angle_degrees();
}
inline void IBISData::set_roll_angle_degrees(float value) {
  _internal_set_roll_angle_degrees(value);
  // @@protoc_insertion_point(field_set:gyroflow.IBISData.roll_angle_degrees)
}
inline float IBISData::_internal_roll_angle_degrees() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roll_angle_degrees_;
}
inline void IBISData::_internal_set_roll_angle_degrees(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roll_angle_degrees_ = value;
}

// -------------------------------------------------------------------

// EISData

// optional double sample_timestamp_us = 1;
inline bool EISData::has_sample_timestamp_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EISData::clear_sample_timestamp_us() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_timestamp_us_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EISData::sample_timestamp_us() const {
  // @@protoc_insertion_point(field_get:gyroflow.EISData.sample_timestamp_us)
  return _internal_sample_timestamp_us();
}
inline void EISData::set_sample_timestamp_us(double value) {
  _internal_set_sample_timestamp_us(value);
  // @@protoc_insertion_point(field_set:gyroflow.EISData.sample_timestamp_us)
}
inline double EISData::_internal_sample_timestamp_us() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_timestamp_us_;
}
inline void EISData::_internal_set_sample_timestamp_us(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sample_timestamp_us_ = value;
}

// .gyroflow.EISData.EISDataType type = 2;
inline void EISData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::gyroflow::EISData_EISDataType EISData::type() const {
  // @@protoc_insertion_point(field_get:gyroflow.EISData.type)
  return _internal_type();
}
inline void EISData::set_type(::gyroflow::EISData_EISDataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:gyroflow.EISData.type)
}
inline ::gyroflow::EISData_EISDataType EISData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gyroflow::EISData_EISDataType>(_impl_.type_);
}
inline void EISData::_internal_set_type(::gyroflow::EISData_EISDataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// optional .gyroflow.Quaternion quaternion = 3;
inline bool EISData::has_quaternion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quaternion_ != nullptr);
  return value;
}
inline void EISData::clear_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.quaternion_ != nullptr) _impl_.quaternion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gyroflow::Quaternion& EISData::_internal_quaternion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::Quaternion* p = _impl_.quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::Quaternion&>(::gyroflow::_Quaternion_default_instance_);
}
inline const ::gyroflow::Quaternion& EISData::quaternion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.EISData.quaternion)
  return _internal_quaternion();
}
inline void EISData::unsafe_arena_set_allocated_quaternion(::gyroflow::Quaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quaternion_);
  }
  _impl_.quaternion_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.EISData.quaternion)
}
inline ::gyroflow::Quaternion* EISData::release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Quaternion* released = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::Quaternion* EISData::unsafe_arena_release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.EISData.quaternion)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gyroflow::Quaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
  return temp;
}
inline ::gyroflow::Quaternion* EISData::_internal_mutable_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::Quaternion>(GetArena());
    _impl_.quaternion_ = reinterpret_cast<::gyroflow::Quaternion*>(p);
  }
  return _impl_.quaternion_;
}
inline ::gyroflow::Quaternion* EISData::mutable_quaternion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::Quaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:gyroflow.EISData.quaternion)
  return _msg;
}
inline void EISData::set_allocated_quaternion(::gyroflow::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::Quaternion*>(_impl_.quaternion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::Quaternion*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.quaternion_ = reinterpret_cast<::gyroflow::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.EISData.quaternion)
}

// optional .gyroflow.MeshWarpData mesh_warp = 4;
inline bool EISData::has_mesh_warp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mesh_warp_ != nullptr);
  return value;
}
inline void EISData::clear_mesh_warp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mesh_warp_ != nullptr) _impl_.mesh_warp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gyroflow::MeshWarpData& EISData::_internal_mesh_warp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gyroflow::MeshWarpData* p = _impl_.mesh_warp_;
  return p != nullptr ? *p : reinterpret_cast<const ::gyroflow::MeshWarpData&>(::gyroflow::_MeshWarpData_default_instance_);
}
inline const ::gyroflow::MeshWarpData& EISData::mesh_warp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gyroflow.EISData.mesh_warp)
  return _internal_mesh_warp();
}
inline void EISData::unsafe_arena_set_allocated_mesh_warp(::gyroflow::MeshWarpData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mesh_warp_);
  }
  _impl_.mesh_warp_ = reinterpret_cast<::gyroflow::MeshWarpData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gyroflow.EISData.mesh_warp)
}
inline ::gyroflow::MeshWarpData* EISData::release_mesh_warp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::MeshWarpData* released = _impl_.mesh_warp_;
  _impl_.mesh_warp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gyroflow::MeshWarpData* EISData::unsafe_arena_release_mesh_warp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gyroflow.EISData.mesh_warp)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gyroflow::MeshWarpData* temp = _impl_.mesh_warp_;
  _impl_.mesh_warp_ = nullptr;
  return temp;
}
inline ::gyroflow::MeshWarpData* EISData::_internal_mutable_mesh_warp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mesh_warp_ == nullptr) {
    auto* p = CreateMaybeMessage<::gyroflow::MeshWarpData>(GetArena());
    _impl_.mesh_warp_ = reinterpret_cast<::gyroflow::MeshWarpData*>(p);
  }
  return _impl_.mesh_warp_;
}
inline ::gyroflow::MeshWarpData* EISData::mutable_mesh_warp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gyroflow::MeshWarpData* _msg = _internal_mutable_mesh_warp();
  // @@protoc_insertion_point(field_mutable:gyroflow.EISData.mesh_warp)
  return _msg;
}
inline void EISData::set_allocated_mesh_warp(::gyroflow::MeshWarpData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::gyroflow::MeshWarpData*>(_impl_.mesh_warp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::gyroflow::MeshWarpData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mesh_warp_ = reinterpret_cast<::gyroflow::MeshWarpData*>(value);
  // @@protoc_insertion_point(field_set_allocated:gyroflow.EISData.mesh_warp)
}

// repeated float matrix_4x4 = 5;
inline int EISData::_internal_matrix_4x4_size() const {
  return _internal_matrix_4x4().size();
}
inline int EISData::matrix_4x4_size() const {
  return _internal_matrix_4x4_size();
}
inline void EISData::clear_matrix_4x4() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matrix_4x4_.Clear();
}
inline float EISData::matrix_4x4(int index) const {
  // @@protoc_insertion_point(field_get:gyroflow.EISData.matrix_4x4)
  return _internal_matrix_4x4().Get(index);
}
inline void EISData::set_matrix_4x4(int index, float value) {
  _internal_mutable_matrix_4x4()->Set(index, value);
  // @@protoc_insertion_point(field_set:gyroflow.EISData.matrix_4x4)
}
inline void EISData::add_matrix_4x4(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_matrix_4x4()->Add(value);
  // @@protoc_insertion_point(field_add:gyroflow.EISData.matrix_4x4)
}
inline const ::google::protobuf::RepeatedField<float>& EISData::matrix_4x4() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.EISData.matrix_4x4)
  return _internal_matrix_4x4();
}
inline ::google::protobuf::RepeatedField<float>* EISData::mutable_matrix_4x4()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.EISData.matrix_4x4)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_matrix_4x4();
}
inline const ::google::protobuf::RepeatedField<float>& EISData::_internal_matrix_4x4()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matrix_4x4_;
}
inline ::google::protobuf::RepeatedField<float>* EISData::_internal_mutable_matrix_4x4() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.matrix_4x4_;
}

// -------------------------------------------------------------------

// MeshWarpData

// int32 grid_width = 1;
inline void MeshWarpData::clear_grid_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.grid_width_ = 0;
}
inline ::int32_t MeshWarpData::grid_width() const {
  // @@protoc_insertion_point(field_get:gyroflow.MeshWarpData.grid_width)
  return _internal_grid_width();
}
inline void MeshWarpData::set_grid_width(::int32_t value) {
  _internal_set_grid_width(value);
  // @@protoc_insertion_point(field_set:gyroflow.MeshWarpData.grid_width)
}
inline ::int32_t MeshWarpData::_internal_grid_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.grid_width_;
}
inline void MeshWarpData::_internal_set_grid_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.grid_width_ = value;
}

// int32 grid_height = 2;
inline void MeshWarpData::clear_grid_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.grid_height_ = 0;
}
inline ::int32_t MeshWarpData::grid_height() const {
  // @@protoc_insertion_point(field_get:gyroflow.MeshWarpData.grid_height)
  return _internal_grid_height();
}
inline void MeshWarpData::set_grid_height(::int32_t value) {
  _internal_set_grid_height(value);
  // @@protoc_insertion_point(field_set:gyroflow.MeshWarpData.grid_height)
}
inline ::int32_t MeshWarpData::_internal_grid_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.grid_height_;
}
inline void MeshWarpData::_internal_set_grid_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.grid_height_ = value;
}

// repeated float values = 3;
inline int MeshWarpData::_internal_values_size() const {
  return _internal_values().size();
}
inline int MeshWarpData::values_size() const {
  return _internal_values_size();
}
inline void MeshWarpData::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline float MeshWarpData::values(int index) const {
  // @@protoc_insertion_point(field_get:gyroflow.MeshWarpData.values)
  return _internal_values().Get(index);
}
inline void MeshWarpData::set_values(int index, float value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:gyroflow.MeshWarpData.values)
}
inline void MeshWarpData::add_values(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:gyroflow.MeshWarpData.values)
}
inline const ::google::protobuf::RepeatedField<float>& MeshWarpData::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gyroflow.MeshWarpData.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<float>* MeshWarpData::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gyroflow.MeshWarpData.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<float>& MeshWarpData::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<float>* MeshWarpData::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace gyroflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::gyroflow::Header_ClipMetadata_ReadoutDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gyroflow::Header_ClipMetadata_ReadoutDirection>() {
  return ::gyroflow::Header_ClipMetadata_ReadoutDirection_descriptor();
}
template <>
struct is_proto_enum<::gyroflow::LensData_DistortionModel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gyroflow::LensData_DistortionModel>() {
  return ::gyroflow::LensData_DistortionModel_descriptor();
}
template <>
struct is_proto_enum<::gyroflow::EISData_EISDataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gyroflow::EISData_EISDataType>() {
  return ::gyroflow::EISData_EISDataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fgyroflow_2eproto_2epb_2eh
